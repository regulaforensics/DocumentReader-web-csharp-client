/* 
 * Regula Document Reader Web API
 *
 * Documents recognition as easy as reading two bytes.  # Clients: * [JavaScript](https://github.com/regulaforensics/DocumentReader-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/DocumentReader-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/DocumentReader-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/DocumentReader-web-csharp-client) client for .NET & .NET Core 
 *
 * The version of the OpenAPI document: 5.7.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Regula.DocumentReader.WebClient.Client.OpenAPIDateConverter;

namespace Regula.DocumentReader.WebClient.Model
{
    /// <summary>
    /// ProcessParams
    /// </summary>
    [DataContract]
    public partial class ProcessParams :  IEquatable<ProcessParams>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessParams" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ProcessParams() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessParams" /> class.
        /// </summary>
        /// <param name="scenario">scenario (required).</param>
        /// <param name="resultTypeOutput">Types of results to return in response. See &#39;Result&#39; enum for available options.</param>
        /// <param name="doublePageSpread">This option can be set to true if the image you provide contains double page spread of the passport and you want to process both pages in one go. It makes sense to use it for documents that have meaningful information on both pages, like Russian domestic passport, or some others. By default is set to false..</param>
        /// <param name="generateDoublePageSpreadImage">When enabled together with \&quot;doublePageSpread\&quot; and there is a passport with two pages spread in the image, pages will be cropped, straightened and aligned together, as if the document was captured on a flatbed scanner..</param>
        /// <param name="fieldTypesFilter">List of text field types to extract. If empty, all text fields from template will be extracted. Narrowing the list can shorten processing time. By default is empty..</param>
        /// <param name="dateFormat">This option allows you to set dates format so that solution will return dates in this format. For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it is set to system locale default (where the service is running)..</param>
        /// <param name="measureSystem">measureSystem.</param>
        /// <param name="imageDpiOutMax">This option controls maximum resolution in dpi of output images. Resolution will remain original in case 0 is supplied. By default is set to return images in response with resolution not greater than 300 dpi..</param>
        /// <param name="alreadyCropped">This option can be set to true if you know for sure that the image you provide contains already cropped document by its edges. This was designed to process on the server side images captured and cropped on mobile. By default is set to false..</param>
        /// <param name="customParams">This option allows to pass custom processing parameters that can be implemented in future without changing API..</param>
        /// <param name="config">This option allows to set additional custom configuration per document type. If recognized document has id specified in config, processing adjusts according to designated configuration..</param>
        /// <param name="log">This option can be set to true if you need to get base64 string of transaction processing log..</param>
        /// <param name="logLevel">logLevel.</param>
        /// <param name="forceDocID">Force use of specific template ID and skip document type identification step..</param>
        /// <param name="matchTextFieldMask">When disabled, text field OCR will be done as is and then the recognized value will be matched to the field mask for validity. If enabled, we are trying to read a field value with maximum efforts to match the mask and provide a correctly formatted value, making assumptions based on the provided field mask in the template..</param>
        /// <param name="fastDocDetect">When enabled, shorten the list of candidates to process during document detection in a single image process mode. Reduces processing time for specific backgrounds..</param>
        /// <param name="updateOCRValidityByGlare">When enabled, fail OCR field validity, if there is a glare over the text field on the image..</param>
        /// <param name="checkRequiredTextFields">When enabled, each field in template will be checked for value presence and if the field is marked as required, but has no value, it will have \&quot;error\&quot; in validity status..</param>
        /// <param name="returnCroppedBarcode">When enabled, returns cropped barcode images for unknown documents.</param>
        /// <param name="imageQA">imageQA.</param>
        /// <param name="forceDocFormat">forceDocFormat.</param>
        /// <param name="noGraphics">When enabled no graphic fields will be cropped from document image..</param>
        /// <param name="documentAreaMin">Specifies minimal area of the image that document should cover to be treated as candidate when locating. Value should be in range from 0 to 1, where 1 is when document should fully cover the image..</param>
        /// <param name="depersonalizeLog">When enabled all personal data will be forcibly removed from the logs..</param>
        /// <param name="multiDocOnImage">This option allows locating and cropping multiple documents from one image if enabled..</param>
        /// <param name="shiftExpiryDate">This option allows shifting the date of expiry into the future or past for number of months specified. This is useful, for example, in some cases when document might be still valid for some period after original expiration date to prevent negative validity status for such documents. Or by shifting the date to the past will set negative validity for the documents that is about to expire in a specified number of months..</param>
        /// <param name="minimalHolderAge">This options allows specifying the minimal age in years of the document holder for the document to be considered valid..</param>
        /// <param name="returnUncroppedImage">This option allows returning input images in output if enabled..</param>
        /// <param name="mrzFormatsFilter">This option allows limiting MRZ formats to be recognized by specifying them in array..</param>
        /// <param name="forceReadMrzBeforeLocate">This option can be set to true to make sure that in series processing MRZ is located fully inside the result document image, if present on the document. Enabling this option may add extra processing time, by disabling optimizations, but allows more stability in output image quality..</param>
        /// <param name="parseBarcodes">This option can be set to false to stop parsing after barcode is read..</param>
        public ProcessParams(string scenario = default(string), List<int> resultTypeOutput = default(List<int>), bool doublePageSpread = default(bool), bool generateDoublePageSpreadImage = default(bool), List<int> fieldTypesFilter = default(List<int>), string dateFormat = default(string), int measureSystem = default(int), int imageDpiOutMax = default(int), bool alreadyCropped = default(bool), Dictionary<string, Object> customParams = default(Dictionary<string, Object>), List<PerDocumentConfig> config = default(List<PerDocumentConfig>), bool log = default(bool), string logLevel = default(string), int forceDocID = default(int), bool matchTextFieldMask = default(bool), bool fastDocDetect = default(bool), bool updateOCRValidityByGlare = default(bool), bool checkRequiredTextFields = default(bool), bool returnCroppedBarcode = default(bool), ImageQA imageQA = default(ImageQA), int forceDocFormat = default(int), bool noGraphics = default(bool), float documentAreaMin = default(float), bool depersonalizeLog = default(bool), bool multiDocOnImage = default(bool), int shiftExpiryDate = default(int), int minimalHolderAge = default(int), bool returnUncroppedImage = default(bool), List<string> mrzFormatsFilter = default(List<string>), bool forceReadMrzBeforeLocate = default(bool), bool parseBarcodes = default(bool))
        {
            // to ensure "scenario" is required (not null)
            if (scenario == null)
            {
                throw new InvalidDataException("scenario is a required property for ProcessParams and cannot be null");
            }
            else
            {
                this.Scenario = scenario;
            }
            
            this.ResultTypeOutput = resultTypeOutput;
            this.DoublePageSpread = doublePageSpread;
            this.GenerateDoublePageSpreadImage = generateDoublePageSpreadImage;
            this.FieldTypesFilter = fieldTypesFilter;
            this.DateFormat = dateFormat;
            this.MeasureSystem = measureSystem;
            this.ImageDpiOutMax = imageDpiOutMax;
            this.AlreadyCropped = alreadyCropped;
            this.CustomParams = customParams;
            this.Config = config;
            this.Log = log;
            this.LogLevel = logLevel;
            this.ForceDocID = forceDocID;
            this.MatchTextFieldMask = matchTextFieldMask;
            this.FastDocDetect = fastDocDetect;
            this.UpdateOCRValidityByGlare = updateOCRValidityByGlare;
            this.CheckRequiredTextFields = checkRequiredTextFields;
            this.ReturnCroppedBarcode = returnCroppedBarcode;
            this.ImageQA = imageQA;
            this.ForceDocFormat = forceDocFormat;
            this.NoGraphics = noGraphics;
            this.DocumentAreaMin = documentAreaMin;
            this.DepersonalizeLog = depersonalizeLog;
            this.MultiDocOnImage = multiDocOnImage;
            this.ShiftExpiryDate = shiftExpiryDate;
            this.MinimalHolderAge = minimalHolderAge;
            this.ReturnUncroppedImage = returnUncroppedImage;
            this.MrzFormatsFilter = mrzFormatsFilter;
            this.ForceReadMrzBeforeLocate = forceReadMrzBeforeLocate;
            this.ParseBarcodes = parseBarcodes;
        }
        
        /// <summary>
        /// Gets or Sets Scenario
        /// </summary>
        [DataMember(Name="scenario", EmitDefaultValue=true)]
        public string Scenario { get; set; }

        /// <summary>
        /// Types of results to return in response. See &#39;Result&#39; enum for available options
        /// </summary>
        /// <value>Types of results to return in response. See &#39;Result&#39; enum for available options</value>
        [DataMember(Name="resultTypeOutput", EmitDefaultValue=false)]
        public List<int> ResultTypeOutput { get; set; }

        /// <summary>
        /// This option can be set to true if the image you provide contains double page spread of the passport and you want to process both pages in one go. It makes sense to use it for documents that have meaningful information on both pages, like Russian domestic passport, or some others. By default is set to false.
        /// </summary>
        /// <value>This option can be set to true if the image you provide contains double page spread of the passport and you want to process both pages in one go. It makes sense to use it for documents that have meaningful information on both pages, like Russian domestic passport, or some others. By default is set to false.</value>
        [DataMember(Name="doublePageSpread", EmitDefaultValue=false)]
        public bool DoublePageSpread { get; set; }

        /// <summary>
        /// When enabled together with \&quot;doublePageSpread\&quot; and there is a passport with two pages spread in the image, pages will be cropped, straightened and aligned together, as if the document was captured on a flatbed scanner.
        /// </summary>
        /// <value>When enabled together with \&quot;doublePageSpread\&quot; and there is a passport with two pages spread in the image, pages will be cropped, straightened and aligned together, as if the document was captured on a flatbed scanner.</value>
        [DataMember(Name="generateDoublePageSpreadImage", EmitDefaultValue=false)]
        public bool GenerateDoublePageSpreadImage { get; set; }

        /// <summary>
        /// List of text field types to extract. If empty, all text fields from template will be extracted. Narrowing the list can shorten processing time. By default is empty.
        /// </summary>
        /// <value>List of text field types to extract. If empty, all text fields from template will be extracted. Narrowing the list can shorten processing time. By default is empty.</value>
        [DataMember(Name="fieldTypesFilter", EmitDefaultValue=false)]
        public List<int> FieldTypesFilter { get; set; }

        /// <summary>
        /// This option allows you to set dates format so that solution will return dates in this format. For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it is set to system locale default (where the service is running).
        /// </summary>
        /// <value>This option allows you to set dates format so that solution will return dates in this format. For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it is set to system locale default (where the service is running).</value>
        [DataMember(Name="dateFormat", EmitDefaultValue=false)]
        public string DateFormat { get; set; }

        /// <summary>
        /// Gets or Sets MeasureSystem
        /// </summary>
        [DataMember(Name="measureSystem", EmitDefaultValue=false)]
        public int MeasureSystem { get; set; }

        /// <summary>
        /// This option controls maximum resolution in dpi of output images. Resolution will remain original in case 0 is supplied. By default is set to return images in response with resolution not greater than 300 dpi.
        /// </summary>
        /// <value>This option controls maximum resolution in dpi of output images. Resolution will remain original in case 0 is supplied. By default is set to return images in response with resolution not greater than 300 dpi.</value>
        [DataMember(Name="imageDpiOutMax", EmitDefaultValue=false)]
        public int ImageDpiOutMax { get; set; }

        /// <summary>
        /// This option can be set to true if you know for sure that the image you provide contains already cropped document by its edges. This was designed to process on the server side images captured and cropped on mobile. By default is set to false.
        /// </summary>
        /// <value>This option can be set to true if you know for sure that the image you provide contains already cropped document by its edges. This was designed to process on the server side images captured and cropped on mobile. By default is set to false.</value>
        [DataMember(Name="alreadyCropped", EmitDefaultValue=false)]
        public bool AlreadyCropped { get; set; }

        /// <summary>
        /// This option allows to pass custom processing parameters that can be implemented in future without changing API.
        /// </summary>
        /// <value>This option allows to pass custom processing parameters that can be implemented in future without changing API.</value>
        [DataMember(Name="customParams", EmitDefaultValue=false)]
        public Dictionary<string, Object> CustomParams { get; set; }

        /// <summary>
        /// This option allows to set additional custom configuration per document type. If recognized document has id specified in config, processing adjusts according to designated configuration.
        /// </summary>
        /// <value>This option allows to set additional custom configuration per document type. If recognized document has id specified in config, processing adjusts according to designated configuration.</value>
        [DataMember(Name="config", EmitDefaultValue=false)]
        public List<PerDocumentConfig> Config { get; set; }

        /// <summary>
        /// This option can be set to true if you need to get base64 string of transaction processing log.
        /// </summary>
        /// <value>This option can be set to true if you need to get base64 string of transaction processing log.</value>
        [DataMember(Name="log", EmitDefaultValue=false)]
        public bool Log { get; set; }

        /// <summary>
        /// Gets or Sets LogLevel
        /// </summary>
        [DataMember(Name="logLevel", EmitDefaultValue=false)]
        public string LogLevel { get; set; }

        /// <summary>
        /// Force use of specific template ID and skip document type identification step.
        /// </summary>
        /// <value>Force use of specific template ID and skip document type identification step.</value>
        [DataMember(Name="forceDocID", EmitDefaultValue=false)]
        public int ForceDocID { get; set; }

        /// <summary>
        /// When disabled, text field OCR will be done as is and then the recognized value will be matched to the field mask for validity. If enabled, we are trying to read a field value with maximum efforts to match the mask and provide a correctly formatted value, making assumptions based on the provided field mask in the template.
        /// </summary>
        /// <value>When disabled, text field OCR will be done as is and then the recognized value will be matched to the field mask for validity. If enabled, we are trying to read a field value with maximum efforts to match the mask and provide a correctly formatted value, making assumptions based on the provided field mask in the template.</value>
        [DataMember(Name="matchTextFieldMask", EmitDefaultValue=false)]
        public bool MatchTextFieldMask { get; set; }

        /// <summary>
        /// When enabled, shorten the list of candidates to process during document detection in a single image process mode. Reduces processing time for specific backgrounds.
        /// </summary>
        /// <value>When enabled, shorten the list of candidates to process during document detection in a single image process mode. Reduces processing time for specific backgrounds.</value>
        [DataMember(Name="fastDocDetect", EmitDefaultValue=false)]
        public bool FastDocDetect { get; set; }

        /// <summary>
        /// When enabled, fail OCR field validity, if there is a glare over the text field on the image.
        /// </summary>
        /// <value>When enabled, fail OCR field validity, if there is a glare over the text field on the image.</value>
        [DataMember(Name="updateOCRValidityByGlare", EmitDefaultValue=false)]
        public bool UpdateOCRValidityByGlare { get; set; }

        /// <summary>
        /// When enabled, each field in template will be checked for value presence and if the field is marked as required, but has no value, it will have \&quot;error\&quot; in validity status.
        /// </summary>
        /// <value>When enabled, each field in template will be checked for value presence and if the field is marked as required, but has no value, it will have \&quot;error\&quot; in validity status.</value>
        [DataMember(Name="checkRequiredTextFields", EmitDefaultValue=false)]
        public bool CheckRequiredTextFields { get; set; }

        /// <summary>
        /// When enabled, returns cropped barcode images for unknown documents
        /// </summary>
        /// <value>When enabled, returns cropped barcode images for unknown documents</value>
        [DataMember(Name="returnCroppedBarcode", EmitDefaultValue=false)]
        public bool ReturnCroppedBarcode { get; set; }

        /// <summary>
        /// Gets or Sets ImageQA
        /// </summary>
        [DataMember(Name="imageQA", EmitDefaultValue=false)]
        public ImageQA ImageQA { get; set; }

        /// <summary>
        /// Gets or Sets ForceDocFormat
        /// </summary>
        [DataMember(Name="forceDocFormat", EmitDefaultValue=false)]
        public int ForceDocFormat { get; set; }

        /// <summary>
        /// When enabled no graphic fields will be cropped from document image.
        /// </summary>
        /// <value>When enabled no graphic fields will be cropped from document image.</value>
        [DataMember(Name="noGraphics", EmitDefaultValue=false)]
        public bool NoGraphics { get; set; }

        /// <summary>
        /// Specifies minimal area of the image that document should cover to be treated as candidate when locating. Value should be in range from 0 to 1, where 1 is when document should fully cover the image.
        /// </summary>
        /// <value>Specifies minimal area of the image that document should cover to be treated as candidate when locating. Value should be in range from 0 to 1, where 1 is when document should fully cover the image.</value>
        [DataMember(Name="documentAreaMin", EmitDefaultValue=false)]
        public float DocumentAreaMin { get; set; }

        /// <summary>
        /// When enabled all personal data will be forcibly removed from the logs.
        /// </summary>
        /// <value>When enabled all personal data will be forcibly removed from the logs.</value>
        [DataMember(Name="depersonalizeLog", EmitDefaultValue=false)]
        public bool DepersonalizeLog { get; set; }

        /// <summary>
        /// This option allows locating and cropping multiple documents from one image if enabled.
        /// </summary>
        /// <value>This option allows locating and cropping multiple documents from one image if enabled.</value>
        [DataMember(Name="multiDocOnImage", EmitDefaultValue=false)]
        public bool MultiDocOnImage { get; set; }

        /// <summary>
        /// This option allows shifting the date of expiry into the future or past for number of months specified. This is useful, for example, in some cases when document might be still valid for some period after original expiration date to prevent negative validity status for such documents. Or by shifting the date to the past will set negative validity for the documents that is about to expire in a specified number of months.
        /// </summary>
        /// <value>This option allows shifting the date of expiry into the future or past for number of months specified. This is useful, for example, in some cases when document might be still valid for some period after original expiration date to prevent negative validity status for such documents. Or by shifting the date to the past will set negative validity for the documents that is about to expire in a specified number of months.</value>
        [DataMember(Name="shiftExpiryDate", EmitDefaultValue=false)]
        public int ShiftExpiryDate { get; set; }

        /// <summary>
        /// This options allows specifying the minimal age in years of the document holder for the document to be considered valid.
        /// </summary>
        /// <value>This options allows specifying the minimal age in years of the document holder for the document to be considered valid.</value>
        [DataMember(Name="minimalHolderAge", EmitDefaultValue=false)]
        public int MinimalHolderAge { get; set; }

        /// <summary>
        /// This option allows returning input images in output if enabled.
        /// </summary>
        /// <value>This option allows returning input images in output if enabled.</value>
        [DataMember(Name="returnUncroppedImage", EmitDefaultValue=false)]
        public bool ReturnUncroppedImage { get; set; }

        /// <summary>
        /// This option allows limiting MRZ formats to be recognized by specifying them in array.
        /// </summary>
        /// <value>This option allows limiting MRZ formats to be recognized by specifying them in array.</value>
        [DataMember(Name="mrzFormatsFilter", EmitDefaultValue=false)]
        public List<string> MrzFormatsFilter { get; set; }

        /// <summary>
        /// This option can be set to true to make sure that in series processing MRZ is located fully inside the result document image, if present on the document. Enabling this option may add extra processing time, by disabling optimizations, but allows more stability in output image quality.
        /// </summary>
        /// <value>This option can be set to true to make sure that in series processing MRZ is located fully inside the result document image, if present on the document. Enabling this option may add extra processing time, by disabling optimizations, but allows more stability in output image quality.</value>
        [DataMember(Name="forceReadMrzBeforeLocate", EmitDefaultValue=false)]
        public bool ForceReadMrzBeforeLocate { get; set; }

        /// <summary>
        /// This option can be set to false to stop parsing after barcode is read.
        /// </summary>
        /// <value>This option can be set to false to stop parsing after barcode is read.</value>
        [DataMember(Name="parseBarcodes", EmitDefaultValue=false)]
        public bool ParseBarcodes { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ProcessParams {\n");
            sb.Append("  Scenario: ").Append(Scenario).Append("\n");
            sb.Append("  ResultTypeOutput: ").Append(ResultTypeOutput).Append("\n");
            sb.Append("  DoublePageSpread: ").Append(DoublePageSpread).Append("\n");
            sb.Append("  GenerateDoublePageSpreadImage: ").Append(GenerateDoublePageSpreadImage).Append("\n");
            sb.Append("  FieldTypesFilter: ").Append(FieldTypesFilter).Append("\n");
            sb.Append("  DateFormat: ").Append(DateFormat).Append("\n");
            sb.Append("  MeasureSystem: ").Append(MeasureSystem).Append("\n");
            sb.Append("  ImageDpiOutMax: ").Append(ImageDpiOutMax).Append("\n");
            sb.Append("  AlreadyCropped: ").Append(AlreadyCropped).Append("\n");
            sb.Append("  CustomParams: ").Append(CustomParams).Append("\n");
            sb.Append("  Config: ").Append(Config).Append("\n");
            sb.Append("  Log: ").Append(Log).Append("\n");
            sb.Append("  LogLevel: ").Append(LogLevel).Append("\n");
            sb.Append("  ForceDocID: ").Append(ForceDocID).Append("\n");
            sb.Append("  MatchTextFieldMask: ").Append(MatchTextFieldMask).Append("\n");
            sb.Append("  FastDocDetect: ").Append(FastDocDetect).Append("\n");
            sb.Append("  UpdateOCRValidityByGlare: ").Append(UpdateOCRValidityByGlare).Append("\n");
            sb.Append("  CheckRequiredTextFields: ").Append(CheckRequiredTextFields).Append("\n");
            sb.Append("  ReturnCroppedBarcode: ").Append(ReturnCroppedBarcode).Append("\n");
            sb.Append("  ImageQA: ").Append(ImageQA).Append("\n");
            sb.Append("  ForceDocFormat: ").Append(ForceDocFormat).Append("\n");
            sb.Append("  NoGraphics: ").Append(NoGraphics).Append("\n");
            sb.Append("  DocumentAreaMin: ").Append(DocumentAreaMin).Append("\n");
            sb.Append("  DepersonalizeLog: ").Append(DepersonalizeLog).Append("\n");
            sb.Append("  MultiDocOnImage: ").Append(MultiDocOnImage).Append("\n");
            sb.Append("  ShiftExpiryDate: ").Append(ShiftExpiryDate).Append("\n");
            sb.Append("  MinimalHolderAge: ").Append(MinimalHolderAge).Append("\n");
            sb.Append("  ReturnUncroppedImage: ").Append(ReturnUncroppedImage).Append("\n");
            sb.Append("  MrzFormatsFilter: ").Append(MrzFormatsFilter).Append("\n");
            sb.Append("  ForceReadMrzBeforeLocate: ").Append(ForceReadMrzBeforeLocate).Append("\n");
            sb.Append("  ParseBarcodes: ").Append(ParseBarcodes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ProcessParams);
        }

        /// <summary>
        /// Returns true if ProcessParams instances are equal
        /// </summary>
        /// <param name="input">Instance of ProcessParams to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ProcessParams input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Scenario == input.Scenario ||
                    (this.Scenario != null &&
                    this.Scenario.Equals(input.Scenario))
                ) && 
                (
                    this.ResultTypeOutput == input.ResultTypeOutput ||
                    this.ResultTypeOutput != null &&
                    input.ResultTypeOutput != null &&
                    this.ResultTypeOutput.SequenceEqual(input.ResultTypeOutput)
                ) && 
                (
                    this.DoublePageSpread == input.DoublePageSpread ||
                    (this.DoublePageSpread != null &&
                    this.DoublePageSpread.Equals(input.DoublePageSpread))
                ) && 
                (
                    this.GenerateDoublePageSpreadImage == input.GenerateDoublePageSpreadImage ||
                    (this.GenerateDoublePageSpreadImage != null &&
                    this.GenerateDoublePageSpreadImage.Equals(input.GenerateDoublePageSpreadImage))
                ) && 
                (
                    this.FieldTypesFilter == input.FieldTypesFilter ||
                    this.FieldTypesFilter != null &&
                    input.FieldTypesFilter != null &&
                    this.FieldTypesFilter.SequenceEqual(input.FieldTypesFilter)
                ) && 
                (
                    this.DateFormat == input.DateFormat ||
                    (this.DateFormat != null &&
                    this.DateFormat.Equals(input.DateFormat))
                ) && 
                (
                    this.MeasureSystem == input.MeasureSystem ||
                    (this.MeasureSystem != null &&
                    this.MeasureSystem.Equals(input.MeasureSystem))
                ) && 
                (
                    this.ImageDpiOutMax == input.ImageDpiOutMax ||
                    (this.ImageDpiOutMax != null &&
                    this.ImageDpiOutMax.Equals(input.ImageDpiOutMax))
                ) && 
                (
                    this.AlreadyCropped == input.AlreadyCropped ||
                    (this.AlreadyCropped != null &&
                    this.AlreadyCropped.Equals(input.AlreadyCropped))
                ) && 
                (
                    this.CustomParams == input.CustomParams ||
                    this.CustomParams != null &&
                    input.CustomParams != null &&
                    this.CustomParams.SequenceEqual(input.CustomParams)
                ) && 
                (
                    this.Config == input.Config ||
                    this.Config != null &&
                    input.Config != null &&
                    this.Config.SequenceEqual(input.Config)
                ) && 
                (
                    this.Log == input.Log ||
                    (this.Log != null &&
                    this.Log.Equals(input.Log))
                ) && 
                (
                    this.LogLevel == input.LogLevel ||
                    (this.LogLevel != null &&
                    this.LogLevel.Equals(input.LogLevel))
                ) && 
                (
                    this.ForceDocID == input.ForceDocID ||
                    (this.ForceDocID != null &&
                    this.ForceDocID.Equals(input.ForceDocID))
                ) && 
                (
                    this.MatchTextFieldMask == input.MatchTextFieldMask ||
                    (this.MatchTextFieldMask != null &&
                    this.MatchTextFieldMask.Equals(input.MatchTextFieldMask))
                ) && 
                (
                    this.FastDocDetect == input.FastDocDetect ||
                    (this.FastDocDetect != null &&
                    this.FastDocDetect.Equals(input.FastDocDetect))
                ) && 
                (
                    this.UpdateOCRValidityByGlare == input.UpdateOCRValidityByGlare ||
                    (this.UpdateOCRValidityByGlare != null &&
                    this.UpdateOCRValidityByGlare.Equals(input.UpdateOCRValidityByGlare))
                ) && 
                (
                    this.CheckRequiredTextFields == input.CheckRequiredTextFields ||
                    (this.CheckRequiredTextFields != null &&
                    this.CheckRequiredTextFields.Equals(input.CheckRequiredTextFields))
                ) && 
                (
                    this.ReturnCroppedBarcode == input.ReturnCroppedBarcode ||
                    (this.ReturnCroppedBarcode != null &&
                    this.ReturnCroppedBarcode.Equals(input.ReturnCroppedBarcode))
                ) && 
                (
                    this.ImageQA == input.ImageQA ||
                    (this.ImageQA != null &&
                    this.ImageQA.Equals(input.ImageQA))
                ) && 
                (
                    this.ForceDocFormat == input.ForceDocFormat ||
                    (this.ForceDocFormat != null &&
                    this.ForceDocFormat.Equals(input.ForceDocFormat))
                ) && 
                (
                    this.NoGraphics == input.NoGraphics ||
                    (this.NoGraphics != null &&
                    this.NoGraphics.Equals(input.NoGraphics))
                ) && 
                (
                    this.DocumentAreaMin == input.DocumentAreaMin ||
                    (this.DocumentAreaMin != null &&
                    this.DocumentAreaMin.Equals(input.DocumentAreaMin))
                ) && 
                (
                    this.DepersonalizeLog == input.DepersonalizeLog ||
                    (this.DepersonalizeLog != null &&
                    this.DepersonalizeLog.Equals(input.DepersonalizeLog))
                ) && 
                (
                    this.MultiDocOnImage == input.MultiDocOnImage ||
                    (this.MultiDocOnImage != null &&
                    this.MultiDocOnImage.Equals(input.MultiDocOnImage))
                ) && 
                (
                    this.ShiftExpiryDate == input.ShiftExpiryDate ||
                    (this.ShiftExpiryDate != null &&
                    this.ShiftExpiryDate.Equals(input.ShiftExpiryDate))
                ) && 
                (
                    this.MinimalHolderAge == input.MinimalHolderAge ||
                    (this.MinimalHolderAge != null &&
                    this.MinimalHolderAge.Equals(input.MinimalHolderAge))
                ) && 
                (
                    this.ReturnUncroppedImage == input.ReturnUncroppedImage ||
                    (this.ReturnUncroppedImage != null &&
                    this.ReturnUncroppedImage.Equals(input.ReturnUncroppedImage))
                ) && 
                (
                    this.MrzFormatsFilter == input.MrzFormatsFilter ||
                    this.MrzFormatsFilter != null &&
                    input.MrzFormatsFilter != null &&
                    this.MrzFormatsFilter.SequenceEqual(input.MrzFormatsFilter)
                ) && 
                (
                    this.ForceReadMrzBeforeLocate == input.ForceReadMrzBeforeLocate ||
                    (this.ForceReadMrzBeforeLocate != null &&
                    this.ForceReadMrzBeforeLocate.Equals(input.ForceReadMrzBeforeLocate))
                ) && 
                (
                    this.ParseBarcodes == input.ParseBarcodes ||
                    (this.ParseBarcodes != null &&
                    this.ParseBarcodes.Equals(input.ParseBarcodes))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Scenario != null)
                    hashCode = hashCode * 59 + this.Scenario.GetHashCode();
                if (this.ResultTypeOutput != null)
                    hashCode = hashCode * 59 + this.ResultTypeOutput.GetHashCode();
                if (this.DoublePageSpread != null)
                    hashCode = hashCode * 59 + this.DoublePageSpread.GetHashCode();
                if (this.GenerateDoublePageSpreadImage != null)
                    hashCode = hashCode * 59 + this.GenerateDoublePageSpreadImage.GetHashCode();
                if (this.FieldTypesFilter != null)
                    hashCode = hashCode * 59 + this.FieldTypesFilter.GetHashCode();
                if (this.DateFormat != null)
                    hashCode = hashCode * 59 + this.DateFormat.GetHashCode();
                if (this.MeasureSystem != null)
                    hashCode = hashCode * 59 + this.MeasureSystem.GetHashCode();
                if (this.ImageDpiOutMax != null)
                    hashCode = hashCode * 59 + this.ImageDpiOutMax.GetHashCode();
                if (this.AlreadyCropped != null)
                    hashCode = hashCode * 59 + this.AlreadyCropped.GetHashCode();
                if (this.CustomParams != null)
                    hashCode = hashCode * 59 + this.CustomParams.GetHashCode();
                if (this.Config != null)
                    hashCode = hashCode * 59 + this.Config.GetHashCode();
                if (this.Log != null)
                    hashCode = hashCode * 59 + this.Log.GetHashCode();
                if (this.LogLevel != null)
                    hashCode = hashCode * 59 + this.LogLevel.GetHashCode();
                if (this.ForceDocID != null)
                    hashCode = hashCode * 59 + this.ForceDocID.GetHashCode();
                if (this.MatchTextFieldMask != null)
                    hashCode = hashCode * 59 + this.MatchTextFieldMask.GetHashCode();
                if (this.FastDocDetect != null)
                    hashCode = hashCode * 59 + this.FastDocDetect.GetHashCode();
                if (this.UpdateOCRValidityByGlare != null)
                    hashCode = hashCode * 59 + this.UpdateOCRValidityByGlare.GetHashCode();
                if (this.CheckRequiredTextFields != null)
                    hashCode = hashCode * 59 + this.CheckRequiredTextFields.GetHashCode();
                if (this.ReturnCroppedBarcode != null)
                    hashCode = hashCode * 59 + this.ReturnCroppedBarcode.GetHashCode();
                if (this.ImageQA != null)
                    hashCode = hashCode * 59 + this.ImageQA.GetHashCode();
                if (this.ForceDocFormat != null)
                    hashCode = hashCode * 59 + this.ForceDocFormat.GetHashCode();
                if (this.NoGraphics != null)
                    hashCode = hashCode * 59 + this.NoGraphics.GetHashCode();
                if (this.DocumentAreaMin != null)
                    hashCode = hashCode * 59 + this.DocumentAreaMin.GetHashCode();
                if (this.DepersonalizeLog != null)
                    hashCode = hashCode * 59 + this.DepersonalizeLog.GetHashCode();
                if (this.MultiDocOnImage != null)
                    hashCode = hashCode * 59 + this.MultiDocOnImage.GetHashCode();
                if (this.ShiftExpiryDate != null)
                    hashCode = hashCode * 59 + this.ShiftExpiryDate.GetHashCode();
                if (this.MinimalHolderAge != null)
                    hashCode = hashCode * 59 + this.MinimalHolderAge.GetHashCode();
                if (this.ReturnUncroppedImage != null)
                    hashCode = hashCode * 59 + this.ReturnUncroppedImage.GetHashCode();
                if (this.MrzFormatsFilter != null)
                    hashCode = hashCode * 59 + this.MrzFormatsFilter.GetHashCode();
                if (this.ForceReadMrzBeforeLocate != null)
                    hashCode = hashCode * 59 + this.ForceReadMrzBeforeLocate.GetHashCode();
                if (this.ParseBarcodes != null)
                    hashCode = hashCode * 59 + this.ParseBarcodes.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
