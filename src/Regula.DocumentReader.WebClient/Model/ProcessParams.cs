// <auto-generated>
/*
 * Regula Document Reader Web API
 *
 * Documents recognition as easy as reading two bytes.   # Clients: * [JavaScript](https://github.com/regulaforensics/DocumentReader-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/DocumentReader-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/DocumentReader-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/DocumentReader-web-csharp-client) client for .NET & .NET Core 
 *
 * The version of the OpenAPI document: 7.4.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Regula.DocumentReader.WebClient.Client;

namespace Regula.DocumentReader.WebClient.Model
{
    /// <summary>
    /// ProcessParams
    /// </summary>
    public partial class ProcessParams : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessParams" /> class.
        /// </summary>
        /// <param name="scenario">scenario</param>
        /// <param name="generateDTCVC">This parameter is used to generate separate DTC-VC data container from RFID session data.</param>
        /// <param name="lcidFilter">The list of LCID types to recognize. If empty, values with all LCID types will be extracted. Empty by default.</param>
        /// <param name="checkLiveness">This parameter is used to enable document liveness check.</param>
        /// <param name="lcidIgnoreFilter">The list of LCID types to ignore during the recognition. If empty, values with all LCID types will be extracted. Narrowing down the list can reduce processing time. Empty by default.</param>
        /// <param name="oneShotIdentification">This parameter allows processing an image that contains a person and a document and compare the portrait photo from the document with the person&#39;s face</param>
        /// <param name="useFaceApi">This parameter allows comparing faces on Regula Face Web Service</param>
        /// <param name="faceApi">faceApi</param>
        /// <param name="doDetectCan">This parameter allows enabling the CAN (Card Access Number) detection and recognition when using scenarios with document location and MRZ reading, such as the MrzAndLocate scenario.</param>
        /// <param name="imageOutputMaxHeight">This parameter allows setting maximum height in pixels of output images and thus reducing image size to desired. Does not change the aspect ratio. Changes disabled if equals to 0. Default 0.</param>
        /// <param name="imageOutputMaxWidth">This parameter allows setting maximum width in pixels of output images and thus reducing image size to desired. Does not change the aspect ratio. Changes disabled if equals to 0. Default 0.</param>
        /// <param name="resultTypeOutput">Types of results to return in response. See &#39;Result&#39; enum for available options</param>
        /// <param name="doublePageSpread">Enable this option if the image you provide contains double page spread of the passport and you want to process both pages in one go. It makes sense to use it for documents that have meaningful information on both pages, like Russian domestic passport, or some others. Disabled by default.</param>
        /// <param name="generateDoublePageSpreadImage">When enabled together with \&quot;doublePageSpread\&quot; and there is a passport with two pages spread in the image, pages will be cropped, straightened and aligned together, as if the document was captured on a flatbed scanner. Disabled by default.</param>
        /// <param name="fieldTypesFilter">List of text field types to extract. If empty, all text fields from template will be extracted. Narrowing the list can shorten processing time. Empty by default.</param>
        /// <param name="dateFormat">This option allows you to set dates format so that solution will return dates in this format. For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it is set to system locale default (where the service is running).</param>
        /// <param name="measureSystem">measureSystem</param>
        /// <param name="imageDpiOutMax">This parameter controls maximum resolution in dpi of output images. Resolution will remain original in case 0 is supplied. By default is set to return images in response with resolution not greater than 300 dpi for all scenarios except FullAuth. In FullAuth scenario this limit is 1000 dpi by default.</param>
        /// <param name="alreadyCropped">This option can be enabled if you know for sure that the image you provide contains already cropped document by its edges. This was designed to process on the server side images captured and cropped on mobile. Disabled by default.</param>
        /// <param name="customParams">This option allows passing custom processing parameters that can be implemented in future without changing API.</param>
        /// <param name="config">This option allows setting additional custom configuration per document type. If recognized document has ID specified in config, processing adjusts according to designated configuration.</param>
        /// <param name="log">When enabled, results will contain transaction processing log. Disabled by default</param>
        /// <param name="logLevel">logLevel</param>
        /// <param name="forceDocID">Force use of specific template ID and skip document type identification step.</param>
        /// <param name="matchTextFieldMask">When disabled, text field OCR will be done as is and then the recognized value will be matched to the field mask for validity. If enabled, we are trying to read a field value with maximum efforts to match the mask and provide a correctly formatted value, making assumptions based on the provided field mask in the template. Enabled by default.</param>
        /// <param name="fastDocDetect">When enabled, shorten the list of candidates to process during document detection in a single image process mode. Reduces processing time for specific backgrounds. Enabled by default.</param>
        /// <param name="updateOCRValidityByGlare">When enabled, fail OCR field validity, if there is a glare over the text field on the image. Disabled by default.</param>
        /// <param name="checkRequiredTextFields">When enabled, each field in template will be checked for value presence and if the field is marked as required, but has no value, it will have &#39;error&#39; in validity status. Disabled by default.</param>
        /// <param name="returnCroppedBarcode">When enabled, returns cropped barcode images for unknown documents. Disabled by default.</param>
        /// <param name="imageQa">imageQa</param>
        /// <param name="strictImageQuality">When enabled, the image quality check status affects the document optical and overall status. Disabled by default.</param>
        /// <param name="respectImageQuality">Deprecated. Please use strictImageQuality instead. When enabled, image quality checks status affects document optical and overall status. Disabled by default.</param>
        /// <param name="forceDocFormat">forceDocFormat</param>
        /// <param name="noGraphics">When enabled, no graphic fields will be cropped from document image. Disabled by default.</param>
        /// <param name="depersonalizeLog">When enabled, all personal data will be forcibly removed from the logs. Disabled by default.</param>
        /// <param name="multiDocOnImage">This option allows locating and cropping multiple documents from one image if enabled. Disabled by default.</param>
        /// <param name="shiftExpiryDate">This option allows shifting the date of expiry into the future or past for number of months specified. This is useful, for example, in some cases when document might be still valid for some period after original expiration date to prevent negative validity status for such documents. Or by shifting the date to the past will set negative validity for the documents that is about to expire in a specified number of months. 0 by default</param>
        /// <param name="minimalHolderAge">This options allows specifying the minimal age in years of the document holder for the document to be considered valid.</param>
        /// <param name="returnUncroppedImage">When enabled, returns input images in output. Disabled by default.</param>
        /// <param name="mrzFormatsFilter">This option allows limiting MRZ formats to be recognized by specifying them in array.</param>
        /// <param name="forceReadMrzBeforeLocate">When enabled, make sure that in series processing MRZ is located fully inside the result document image, if present on the document. Enabling this option may add extra processing time, by disabling optimizations, but allows more stability in output image quality. Disabled by default.</param>
        /// <param name="parseBarcodes">This option can be disabled to stop parsing after barcode is read. Enabled by default.</param>
        /// <param name="convertCase">convertCase</param>
        /// <param name="splitNames">When enabled, the Surname and GivenNames fields from MRZ will be divided into ft_First_Name, ft_Second_Name, ft_Third_Name, ft_Fourth_Name, ft_Last_Name fields. Disabled by default.</param>
        /// <param name="disablePerforationOCR">When enabled, OCR of perforated fields in the document template will not be performed. Disabled by default.</param>
        /// <param name="documentGroupFilter">List of specific eligible document types from DocumentType enum to recognize from. You may, for example, specify only passports to be recognized by setting this property. Empty by default.</param>
        /// <param name="processAuth">Authenticity checks that should be performed regardless of the document type. The available checks are listed in the eRPRM_Authenticity enum. Note that only supported by your license checks can be added. </param>
        /// <param name="deviceId">This parameter is used to specify the document reader device type from which input images were captured. Default 0.</param>
        /// <param name="deviceType">This parameter is used to specify the document reader device type from which input images were captured. Default 0.</param>
        /// <param name="deviceTypeHex">This parameter is used to specify the document reader device type from which input images were captured</param>
        /// <param name="ignoreDeviceIdFromImage">This parameter is used to tell the processing engine to ignore any parameters saved in the image when scanned from the document reader device. Default false</param>
        /// <param name="documentIdList">List of the document ID&#39;s to process. All documents will be processed, if empty.</param>
        /// <param name="rfid">rfid</param>
        /// <param name="checkAuth">This parameter is used to enable authenticity checks</param>
        /// <param name="authParams">authParams</param>
        /// <param name="mrzDetectMode">mrzDetectMode</param>
        /// <param name="generateNumericCodes">This parameter is used to generate numeric representation for issuing state and nationality codes</param>
        /// <param name="strictBarcodeDigitalSignatureCheck">This parameter if enabled will require all necessary certificates to verify digital signature in barcode data to be present in order for the Barcode format check to succeed.</param>
        /// <param name="selectLongestNames">Select the longest value from the different value sources and write it to the value field if comparison is done successfully. The parameter applies this logic to the personal names, such as given name, surname, surname and given name, middle name and etc.</param>
        /// <param name="doBarcodes">Set the types of barcodes to process.</param>
        [JsonConstructor]
        public ProcessParams(Scenario scenario, Option<bool?> generateDTCVC = default, Option<List<LCID>?> lcidFilter = default, Option<bool?> checkLiveness = default, Option<List<LCID>?> lcidIgnoreFilter = default, Option<bool?> oneShotIdentification = default, Option<bool?> useFaceApi = default, Option<FaceApi?> faceApi = default, Option<bool?> doDetectCan = default, Option<int?> imageOutputMaxHeight = default, Option<int?> imageOutputMaxWidth = default, Option<List<Result>?> resultTypeOutput = default, Option<bool?> doublePageSpread = default, Option<bool?> generateDoublePageSpreadImage = default, Option<List<TextFieldType>?> fieldTypesFilter = default, Option<string?> dateFormat = default, Option<MeasureSystem?> measureSystem = default, Option<int?> imageDpiOutMax = default, Option<bool?> alreadyCropped = default, Option<Dictionary<string, Object>?> customParams = default, Option<List<PerDocumentConfig>?> config = default, Option<bool?> log = default, Option<LogLevel?> logLevel = default, Option<int?> forceDocID = default, Option<bool?> matchTextFieldMask = default, Option<bool?> fastDocDetect = default, Option<bool?> updateOCRValidityByGlare = default, Option<bool?> checkRequiredTextFields = default, Option<bool?> returnCroppedBarcode = default, Option<ImageQA?> imageQa = default, Option<bool?> strictImageQuality = default, Option<bool?> respectImageQuality = default, Option<DocumentFormat?> forceDocFormat = default, Option<bool?> noGraphics = default, Option<bool?> depersonalizeLog = default, Option<bool?> multiDocOnImage = default, Option<int?> shiftExpiryDate = default, Option<int?> minimalHolderAge = default, Option<bool?> returnUncroppedImage = default, Option<List<MRZFormat>?> mrzFormatsFilter = default, Option<bool?> forceReadMrzBeforeLocate = default, Option<bool?> parseBarcodes = default, Option<TextPostProcessing?> convertCase = default, Option<bool?> splitNames = default, Option<bool?> disablePerforationOCR = default, Option<List<DocumentType>?> documentGroupFilter = default, Option<long?> processAuth = default, Option<int?> deviceId = default, Option<int?> deviceType = default, Option<string?> deviceTypeHex = default, Option<bool?> ignoreDeviceIdFromImage = default, Option<List<int>?> documentIdList = default, Option<ProcessParamsRfid?> rfid = default, Option<bool?> checkAuth = default, Option<AuthParams?> authParams = default, Option<MrzDetectModeEnum?> mrzDetectMode = default, Option<bool?> generateNumericCodes = default, Option<bool?> strictBarcodeDigitalSignatureCheck = default, Option<bool?> selectLongestNames = default, Option<List<InputBarcodeType>?> doBarcodes = default)
        {
            Scenario = scenario;
            GenerateDTCVCOption = generateDTCVC;
            LcidFilterOption = lcidFilter;
            CheckLivenessOption = checkLiveness;
            LcidIgnoreFilterOption = lcidIgnoreFilter;
            OneShotIdentificationOption = oneShotIdentification;
            UseFaceApiOption = useFaceApi;
            FaceApiOption = faceApi;
            DoDetectCanOption = doDetectCan;
            ImageOutputMaxHeightOption = imageOutputMaxHeight;
            ImageOutputMaxWidthOption = imageOutputMaxWidth;
            ResultTypeOutputOption = resultTypeOutput;
            DoublePageSpreadOption = doublePageSpread;
            GenerateDoublePageSpreadImageOption = generateDoublePageSpreadImage;
            FieldTypesFilterOption = fieldTypesFilter;
            DateFormatOption = dateFormat;
            MeasureSystemOption = measureSystem;
            ImageDpiOutMaxOption = imageDpiOutMax;
            AlreadyCroppedOption = alreadyCropped;
            CustomParamsOption = customParams;
            ConfigOption = config;
            LogOption = log;
            LogLevelOption = logLevel;
            ForceDocIDOption = forceDocID;
            MatchTextFieldMaskOption = matchTextFieldMask;
            FastDocDetectOption = fastDocDetect;
            UpdateOCRValidityByGlareOption = updateOCRValidityByGlare;
            CheckRequiredTextFieldsOption = checkRequiredTextFields;
            ReturnCroppedBarcodeOption = returnCroppedBarcode;
            ImageQaOption = imageQa;
            StrictImageQualityOption = strictImageQuality;
            RespectImageQualityOption = respectImageQuality;
            ForceDocFormatOption = forceDocFormat;
            NoGraphicsOption = noGraphics;
            DepersonalizeLogOption = depersonalizeLog;
            MultiDocOnImageOption = multiDocOnImage;
            ShiftExpiryDateOption = shiftExpiryDate;
            MinimalHolderAgeOption = minimalHolderAge;
            ReturnUncroppedImageOption = returnUncroppedImage;
            MrzFormatsFilterOption = mrzFormatsFilter;
            ForceReadMrzBeforeLocateOption = forceReadMrzBeforeLocate;
            ParseBarcodesOption = parseBarcodes;
            ConvertCaseOption = convertCase;
            SplitNamesOption = splitNames;
            DisablePerforationOCROption = disablePerforationOCR;
            DocumentGroupFilterOption = documentGroupFilter;
            ProcessAuthOption = processAuth;
            DeviceIdOption = deviceId;
            DeviceTypeOption = deviceType;
            DeviceTypeHexOption = deviceTypeHex;
            IgnoreDeviceIdFromImageOption = ignoreDeviceIdFromImage;
            DocumentIdListOption = documentIdList;
            RfidOption = rfid;
            CheckAuthOption = checkAuth;
            AuthParamsOption = authParams;
            MrzDetectModeOption = mrzDetectMode;
            GenerateNumericCodesOption = generateNumericCodes;
            StrictBarcodeDigitalSignatureCheckOption = strictBarcodeDigitalSignatureCheck;
            SelectLongestNamesOption = selectLongestNames;
            DoBarcodesOption = doBarcodes;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets Scenario
        /// </summary>
        [JsonPropertyName("scenario")]
        public Scenario Scenario { get; set; }

        /// <summary>
        /// Used to track the state of MeasureSystem
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<MeasureSystem?> MeasureSystemOption { get; private set; }

        /// <summary>
        /// Gets or Sets MeasureSystem
        /// </summary>
        [JsonPropertyName("measureSystem")]
        public MeasureSystem? MeasureSystem { get { return this.MeasureSystemOption; } set { this.MeasureSystemOption = new Option<MeasureSystem?>(value); } }

        /// <summary>
        /// Used to track the state of LogLevel
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<LogLevel?> LogLevelOption { get; private set; }

        /// <summary>
        /// Gets or Sets LogLevel
        /// </summary>
        [JsonPropertyName("logLevel")]
        public LogLevel? LogLevel { get { return this.LogLevelOption; } set { this.LogLevelOption = new Option<LogLevel?>(value); } }

        /// <summary>
        /// Used to track the state of ForceDocFormat
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DocumentFormat?> ForceDocFormatOption { get; private set; }

        /// <summary>
        /// Gets or Sets ForceDocFormat
        /// </summary>
        [JsonPropertyName("forceDocFormat")]
        public DocumentFormat? ForceDocFormat { get { return this.ForceDocFormatOption; } set { this.ForceDocFormatOption = new Option<DocumentFormat?>(value); } }

        /// <summary>
        /// Used to track the state of ConvertCase
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TextPostProcessing?> ConvertCaseOption { get; private set; }

        /// <summary>
        /// Gets or Sets ConvertCase
        /// </summary>
        [JsonPropertyName("convertCase")]
        public TextPostProcessing? ConvertCase { get { return this.ConvertCaseOption; } set { this.ConvertCaseOption = new Option<TextPostProcessing?>(value); } }

        /// <summary>
        /// Used to track the state of MrzDetectMode
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<MrzDetectModeEnum?> MrzDetectModeOption { get; private set; }

        /// <summary>
        /// Gets or Sets MrzDetectMode
        /// </summary>
        [JsonPropertyName("mrzDetectMode")]
        public MrzDetectModeEnum? MrzDetectMode { get { return this.MrzDetectModeOption; } set { this.MrzDetectModeOption = new Option<MrzDetectModeEnum?>(value); } }

        /// <summary>
        /// Used to track the state of GenerateDTCVC
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> GenerateDTCVCOption { get; private set; }

        /// <summary>
        /// This parameter is used to generate separate DTC-VC data container from RFID session data.
        /// </summary>
        /// <value>This parameter is used to generate separate DTC-VC data container from RFID session data.</value>
        [JsonPropertyName("generateDTCVC")]
        public bool? GenerateDTCVC { get { return this.GenerateDTCVCOption; } set { this.GenerateDTCVCOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of LcidFilter
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<LCID>?> LcidFilterOption { get; private set; }

        /// <summary>
        /// The list of LCID types to recognize. If empty, values with all LCID types will be extracted. Empty by default.
        /// </summary>
        /// <value>The list of LCID types to recognize. If empty, values with all LCID types will be extracted. Empty by default.</value>
        [JsonPropertyName("lcidFilter")]
        public List<LCID>? LcidFilter { get { return this.LcidFilterOption; } set { this.LcidFilterOption = new Option<List<LCID>?>(value); } }

        /// <summary>
        /// Used to track the state of CheckLiveness
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> CheckLivenessOption { get; private set; }

        /// <summary>
        /// This parameter is used to enable document liveness check.
        /// </summary>
        /// <value>This parameter is used to enable document liveness check.</value>
        [JsonPropertyName("checkLiveness")]
        public bool? CheckLiveness { get { return this.CheckLivenessOption; } set { this.CheckLivenessOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of LcidIgnoreFilter
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<LCID>?> LcidIgnoreFilterOption { get; private set; }

        /// <summary>
        /// The list of LCID types to ignore during the recognition. If empty, values with all LCID types will be extracted. Narrowing down the list can reduce processing time. Empty by default.
        /// </summary>
        /// <value>The list of LCID types to ignore during the recognition. If empty, values with all LCID types will be extracted. Narrowing down the list can reduce processing time. Empty by default.</value>
        [JsonPropertyName("lcidIgnoreFilter")]
        public List<LCID>? LcidIgnoreFilter { get { return this.LcidIgnoreFilterOption; } set { this.LcidIgnoreFilterOption = new Option<List<LCID>?>(value); } }

        /// <summary>
        /// Used to track the state of OneShotIdentification
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> OneShotIdentificationOption { get; private set; }

        /// <summary>
        /// This parameter allows processing an image that contains a person and a document and compare the portrait photo from the document with the person&#39;s face
        /// </summary>
        /// <value>This parameter allows processing an image that contains a person and a document and compare the portrait photo from the document with the person&#39;s face</value>
        [JsonPropertyName("oneShotIdentification")]
        public bool? OneShotIdentification { get { return this.OneShotIdentificationOption; } set { this.OneShotIdentificationOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of UseFaceApi
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> UseFaceApiOption { get; private set; }

        /// <summary>
        /// This parameter allows comparing faces on Regula Face Web Service
        /// </summary>
        /// <value>This parameter allows comparing faces on Regula Face Web Service</value>
        [JsonPropertyName("useFaceApi")]
        public bool? UseFaceApi { get { return this.UseFaceApiOption; } set { this.UseFaceApiOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of FaceApi
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<FaceApi?> FaceApiOption { get; private set; }

        /// <summary>
        /// Gets or Sets FaceApi
        /// </summary>
        [JsonPropertyName("faceApi")]
        public FaceApi? FaceApi { get { return this.FaceApiOption; } set { this.FaceApiOption = new Option<FaceApi?>(value); } }

        /// <summary>
        /// Used to track the state of DoDetectCan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> DoDetectCanOption { get; private set; }

        /// <summary>
        /// This parameter allows enabling the CAN (Card Access Number) detection and recognition when using scenarios with document location and MRZ reading, such as the MrzAndLocate scenario.
        /// </summary>
        /// <value>This parameter allows enabling the CAN (Card Access Number) detection and recognition when using scenarios with document location and MRZ reading, such as the MrzAndLocate scenario.</value>
        [JsonPropertyName("doDetectCan")]
        public bool? DoDetectCan { get { return this.DoDetectCanOption; } set { this.DoDetectCanOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of ImageOutputMaxHeight
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ImageOutputMaxHeightOption { get; private set; }

        /// <summary>
        /// This parameter allows setting maximum height in pixels of output images and thus reducing image size to desired. Does not change the aspect ratio. Changes disabled if equals to 0. Default 0.
        /// </summary>
        /// <value>This parameter allows setting maximum height in pixels of output images and thus reducing image size to desired. Does not change the aspect ratio. Changes disabled if equals to 0. Default 0.</value>
        [JsonPropertyName("imageOutputMaxHeight")]
        public int? ImageOutputMaxHeight { get { return this.ImageOutputMaxHeightOption; } set { this.ImageOutputMaxHeightOption = new Option<int?>(value); } }

        /// <summary>
        /// Used to track the state of ImageOutputMaxWidth
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ImageOutputMaxWidthOption { get; private set; }

        /// <summary>
        /// This parameter allows setting maximum width in pixels of output images and thus reducing image size to desired. Does not change the aspect ratio. Changes disabled if equals to 0. Default 0.
        /// </summary>
        /// <value>This parameter allows setting maximum width in pixels of output images and thus reducing image size to desired. Does not change the aspect ratio. Changes disabled if equals to 0. Default 0.</value>
        [JsonPropertyName("imageOutputMaxWidth")]
        public int? ImageOutputMaxWidth { get { return this.ImageOutputMaxWidthOption; } set { this.ImageOutputMaxWidthOption = new Option<int?>(value); } }

        /// <summary>
        /// Used to track the state of ResultTypeOutput
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<Result>?> ResultTypeOutputOption { get; private set; }

        /// <summary>
        /// Types of results to return in response. See &#39;Result&#39; enum for available options
        /// </summary>
        /// <value>Types of results to return in response. See &#39;Result&#39; enum for available options</value>
        [JsonPropertyName("resultTypeOutput")]
        public List<Result>? ResultTypeOutput { get { return this.ResultTypeOutputOption; } set { this.ResultTypeOutputOption = new Option<List<Result>?>(value); } }

        /// <summary>
        /// Used to track the state of DoublePageSpread
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> DoublePageSpreadOption { get; private set; }

        /// <summary>
        /// Enable this option if the image you provide contains double page spread of the passport and you want to process both pages in one go. It makes sense to use it for documents that have meaningful information on both pages, like Russian domestic passport, or some others. Disabled by default.
        /// </summary>
        /// <value>Enable this option if the image you provide contains double page spread of the passport and you want to process both pages in one go. It makes sense to use it for documents that have meaningful information on both pages, like Russian domestic passport, or some others. Disabled by default.</value>
        [JsonPropertyName("doublePageSpread")]
        [Obsolete]
        public bool? DoublePageSpread { get { return this.DoublePageSpreadOption; } set { this.DoublePageSpreadOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of GenerateDoublePageSpreadImage
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> GenerateDoublePageSpreadImageOption { get; private set; }

        /// <summary>
        /// When enabled together with \&quot;doublePageSpread\&quot; and there is a passport with two pages spread in the image, pages will be cropped, straightened and aligned together, as if the document was captured on a flatbed scanner. Disabled by default.
        /// </summary>
        /// <value>When enabled together with \&quot;doublePageSpread\&quot; and there is a passport with two pages spread in the image, pages will be cropped, straightened and aligned together, as if the document was captured on a flatbed scanner. Disabled by default.</value>
        [JsonPropertyName("generateDoublePageSpreadImage")]
        public bool? GenerateDoublePageSpreadImage { get { return this.GenerateDoublePageSpreadImageOption; } set { this.GenerateDoublePageSpreadImageOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of FieldTypesFilter
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<TextFieldType>?> FieldTypesFilterOption { get; private set; }

        /// <summary>
        /// List of text field types to extract. If empty, all text fields from template will be extracted. Narrowing the list can shorten processing time. Empty by default.
        /// </summary>
        /// <value>List of text field types to extract. If empty, all text fields from template will be extracted. Narrowing the list can shorten processing time. Empty by default.</value>
        [JsonPropertyName("fieldTypesFilter")]
        public List<TextFieldType>? FieldTypesFilter { get { return this.FieldTypesFilterOption; } set { this.FieldTypesFilterOption = new Option<List<TextFieldType>?>(value); } }

        /// <summary>
        /// Used to track the state of DateFormat
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DateFormatOption { get; private set; }

        /// <summary>
        /// This option allows you to set dates format so that solution will return dates in this format. For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it is set to system locale default (where the service is running).
        /// </summary>
        /// <value>This option allows you to set dates format so that solution will return dates in this format. For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it is set to system locale default (where the service is running).</value>
        /* <example>MM/dd/yyyy</example> */
        [JsonPropertyName("dateFormat")]
        public string? DateFormat { get { return this.DateFormatOption; } set { this.DateFormatOption = new Option<string?>(value); } }

        /// <summary>
        /// Used to track the state of ImageDpiOutMax
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ImageDpiOutMaxOption { get; private set; }

        /// <summary>
        /// This parameter controls maximum resolution in dpi of output images. Resolution will remain original in case 0 is supplied. By default is set to return images in response with resolution not greater than 300 dpi for all scenarios except FullAuth. In FullAuth scenario this limit is 1000 dpi by default.
        /// </summary>
        /// <value>This parameter controls maximum resolution in dpi of output images. Resolution will remain original in case 0 is supplied. By default is set to return images in response with resolution not greater than 300 dpi for all scenarios except FullAuth. In FullAuth scenario this limit is 1000 dpi by default.</value>
        [JsonPropertyName("imageDpiOutMax")]
        public int? ImageDpiOutMax { get { return this.ImageDpiOutMaxOption; } set { this.ImageDpiOutMaxOption = new Option<int?>(value); } }

        /// <summary>
        /// Used to track the state of AlreadyCropped
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> AlreadyCroppedOption { get; private set; }

        /// <summary>
        /// This option can be enabled if you know for sure that the image you provide contains already cropped document by its edges. This was designed to process on the server side images captured and cropped on mobile. Disabled by default.
        /// </summary>
        /// <value>This option can be enabled if you know for sure that the image you provide contains already cropped document by its edges. This was designed to process on the server side images captured and cropped on mobile. Disabled by default.</value>
        [JsonPropertyName("alreadyCropped")]
        public bool? AlreadyCropped { get { return this.AlreadyCroppedOption; } set { this.AlreadyCroppedOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of CustomParams
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, Object>?> CustomParamsOption { get; private set; }

        /// <summary>
        /// This option allows passing custom processing parameters that can be implemented in future without changing API.
        /// </summary>
        /// <value>This option allows passing custom processing parameters that can be implemented in future without changing API.</value>
        [JsonPropertyName("customParams")]
        public Dictionary<string, Object>? CustomParams { get { return this.CustomParamsOption; } set { this.CustomParamsOption = new Option<Dictionary<string, Object>?>(value); } }

        /// <summary>
        /// Used to track the state of Config
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<PerDocumentConfig>?> ConfigOption { get; private set; }

        /// <summary>
        /// This option allows setting additional custom configuration per document type. If recognized document has ID specified in config, processing adjusts according to designated configuration.
        /// </summary>
        /// <value>This option allows setting additional custom configuration per document type. If recognized document has ID specified in config, processing adjusts according to designated configuration.</value>
        [JsonPropertyName("config")]
        public List<PerDocumentConfig>? Config { get { return this.ConfigOption; } set { this.ConfigOption = new Option<List<PerDocumentConfig>?>(value); } }

        /// <summary>
        /// Used to track the state of Log
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> LogOption { get; private set; }

        /// <summary>
        /// When enabled, results will contain transaction processing log. Disabled by default
        /// </summary>
        /// <value>When enabled, results will contain transaction processing log. Disabled by default</value>
        [JsonPropertyName("log")]
        public bool? Log { get { return this.LogOption; } set { this.LogOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of ForceDocID
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ForceDocIDOption { get; private set; }

        /// <summary>
        /// Force use of specific template ID and skip document type identification step.
        /// </summary>
        /// <value>Force use of specific template ID and skip document type identification step.</value>
        [JsonPropertyName("forceDocID")]
        public int? ForceDocID { get { return this.ForceDocIDOption; } set { this.ForceDocIDOption = new Option<int?>(value); } }

        /// <summary>
        /// Used to track the state of MatchTextFieldMask
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> MatchTextFieldMaskOption { get; private set; }

        /// <summary>
        /// When disabled, text field OCR will be done as is and then the recognized value will be matched to the field mask for validity. If enabled, we are trying to read a field value with maximum efforts to match the mask and provide a correctly formatted value, making assumptions based on the provided field mask in the template. Enabled by default.
        /// </summary>
        /// <value>When disabled, text field OCR will be done as is and then the recognized value will be matched to the field mask for validity. If enabled, we are trying to read a field value with maximum efforts to match the mask and provide a correctly formatted value, making assumptions based on the provided field mask in the template. Enabled by default.</value>
        [JsonPropertyName("matchTextFieldMask")]
        public bool? MatchTextFieldMask { get { return this.MatchTextFieldMaskOption; } set { this.MatchTextFieldMaskOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of FastDocDetect
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> FastDocDetectOption { get; private set; }

        /// <summary>
        /// When enabled, shorten the list of candidates to process during document detection in a single image process mode. Reduces processing time for specific backgrounds. Enabled by default.
        /// </summary>
        /// <value>When enabled, shorten the list of candidates to process during document detection in a single image process mode. Reduces processing time for specific backgrounds. Enabled by default.</value>
        [JsonPropertyName("fastDocDetect")]
        [Obsolete]
        public bool? FastDocDetect { get { return this.FastDocDetectOption; } set { this.FastDocDetectOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of UpdateOCRValidityByGlare
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> UpdateOCRValidityByGlareOption { get; private set; }

        /// <summary>
        /// When enabled, fail OCR field validity, if there is a glare over the text field on the image. Disabled by default.
        /// </summary>
        /// <value>When enabled, fail OCR field validity, if there is a glare over the text field on the image. Disabled by default.</value>
        [JsonPropertyName("updateOCRValidityByGlare")]
        public bool? UpdateOCRValidityByGlare { get { return this.UpdateOCRValidityByGlareOption; } set { this.UpdateOCRValidityByGlareOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of CheckRequiredTextFields
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> CheckRequiredTextFieldsOption { get; private set; }

        /// <summary>
        /// When enabled, each field in template will be checked for value presence and if the field is marked as required, but has no value, it will have &#39;error&#39; in validity status. Disabled by default.
        /// </summary>
        /// <value>When enabled, each field in template will be checked for value presence and if the field is marked as required, but has no value, it will have &#39;error&#39; in validity status. Disabled by default.</value>
        [JsonPropertyName("checkRequiredTextFields")]
        public bool? CheckRequiredTextFields { get { return this.CheckRequiredTextFieldsOption; } set { this.CheckRequiredTextFieldsOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of ReturnCroppedBarcode
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ReturnCroppedBarcodeOption { get; private set; }

        /// <summary>
        /// When enabled, returns cropped barcode images for unknown documents. Disabled by default.
        /// </summary>
        /// <value>When enabled, returns cropped barcode images for unknown documents. Disabled by default.</value>
        [JsonPropertyName("returnCroppedBarcode")]
        public bool? ReturnCroppedBarcode { get { return this.ReturnCroppedBarcodeOption; } set { this.ReturnCroppedBarcodeOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of ImageQa
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ImageQA?> ImageQaOption { get; private set; }

        /// <summary>
        /// Gets or Sets ImageQa
        /// </summary>
        [JsonPropertyName("imageQa")]
        public ImageQA? ImageQa { get { return this.ImageQaOption; } set { this.ImageQaOption = new Option<ImageQA?>(value); } }

        /// <summary>
        /// Used to track the state of StrictImageQuality
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> StrictImageQualityOption { get; private set; }

        /// <summary>
        /// When enabled, the image quality check status affects the document optical and overall status. Disabled by default.
        /// </summary>
        /// <value>When enabled, the image quality check status affects the document optical and overall status. Disabled by default.</value>
        [JsonPropertyName("strictImageQuality")]
        public bool? StrictImageQuality { get { return this.StrictImageQualityOption; } set { this.StrictImageQualityOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of RespectImageQuality
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> RespectImageQualityOption { get; private set; }

        /// <summary>
        /// Deprecated. Please use strictImageQuality instead. When enabled, image quality checks status affects document optical and overall status. Disabled by default.
        /// </summary>
        /// <value>Deprecated. Please use strictImageQuality instead. When enabled, image quality checks status affects document optical and overall status. Disabled by default.</value>
        [JsonPropertyName("respectImageQuality")]
        [Obsolete]
        public bool? RespectImageQuality { get { return this.RespectImageQualityOption; } set { this.RespectImageQualityOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of NoGraphics
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> NoGraphicsOption { get; private set; }

        /// <summary>
        /// When enabled, no graphic fields will be cropped from document image. Disabled by default.
        /// </summary>
        /// <value>When enabled, no graphic fields will be cropped from document image. Disabled by default.</value>
        [JsonPropertyName("noGraphics")]
        public bool? NoGraphics { get { return this.NoGraphicsOption; } set { this.NoGraphicsOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of DepersonalizeLog
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> DepersonalizeLogOption { get; private set; }

        /// <summary>
        /// When enabled, all personal data will be forcibly removed from the logs. Disabled by default.
        /// </summary>
        /// <value>When enabled, all personal data will be forcibly removed from the logs. Disabled by default.</value>
        [JsonPropertyName("depersonalizeLog")]
        public bool? DepersonalizeLog { get { return this.DepersonalizeLogOption; } set { this.DepersonalizeLogOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of MultiDocOnImage
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> MultiDocOnImageOption { get; private set; }

        /// <summary>
        /// This option allows locating and cropping multiple documents from one image if enabled. Disabled by default.
        /// </summary>
        /// <value>This option allows locating and cropping multiple documents from one image if enabled. Disabled by default.</value>
        [JsonPropertyName("multiDocOnImage")]
        public bool? MultiDocOnImage { get { return this.MultiDocOnImageOption; } set { this.MultiDocOnImageOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of ShiftExpiryDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ShiftExpiryDateOption { get; private set; }

        /// <summary>
        /// This option allows shifting the date of expiry into the future or past for number of months specified. This is useful, for example, in some cases when document might be still valid for some period after original expiration date to prevent negative validity status for such documents. Or by shifting the date to the past will set negative validity for the documents that is about to expire in a specified number of months. 0 by default
        /// </summary>
        /// <value>This option allows shifting the date of expiry into the future or past for number of months specified. This is useful, for example, in some cases when document might be still valid for some period after original expiration date to prevent negative validity status for such documents. Or by shifting the date to the past will set negative validity for the documents that is about to expire in a specified number of months. 0 by default</value>
        [JsonPropertyName("shiftExpiryDate")]
        public int? ShiftExpiryDate { get { return this.ShiftExpiryDateOption; } set { this.ShiftExpiryDateOption = new Option<int?>(value); } }

        /// <summary>
        /// Used to track the state of MinimalHolderAge
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> MinimalHolderAgeOption { get; private set; }

        /// <summary>
        /// This options allows specifying the minimal age in years of the document holder for the document to be considered valid.
        /// </summary>
        /// <value>This options allows specifying the minimal age in years of the document holder for the document to be considered valid.</value>
        [JsonPropertyName("minimalHolderAge")]
        public int? MinimalHolderAge { get { return this.MinimalHolderAgeOption; } set { this.MinimalHolderAgeOption = new Option<int?>(value); } }

        /// <summary>
        /// Used to track the state of ReturnUncroppedImage
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ReturnUncroppedImageOption { get; private set; }

        /// <summary>
        /// When enabled, returns input images in output. Disabled by default.
        /// </summary>
        /// <value>When enabled, returns input images in output. Disabled by default.</value>
        [JsonPropertyName("returnUncroppedImage")]
        public bool? ReturnUncroppedImage { get { return this.ReturnUncroppedImageOption; } set { this.ReturnUncroppedImageOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of MrzFormatsFilter
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<MRZFormat>?> MrzFormatsFilterOption { get; private set; }

        /// <summary>
        /// This option allows limiting MRZ formats to be recognized by specifying them in array.
        /// </summary>
        /// <value>This option allows limiting MRZ formats to be recognized by specifying them in array.</value>
        [JsonPropertyName("mrzFormatsFilter")]
        public List<MRZFormat>? MrzFormatsFilter { get { return this.MrzFormatsFilterOption; } set { this.MrzFormatsFilterOption = new Option<List<MRZFormat>?>(value); } }

        /// <summary>
        /// Used to track the state of ForceReadMrzBeforeLocate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ForceReadMrzBeforeLocateOption { get; private set; }

        /// <summary>
        /// When enabled, make sure that in series processing MRZ is located fully inside the result document image, if present on the document. Enabling this option may add extra processing time, by disabling optimizations, but allows more stability in output image quality. Disabled by default.
        /// </summary>
        /// <value>When enabled, make sure that in series processing MRZ is located fully inside the result document image, if present on the document. Enabling this option may add extra processing time, by disabling optimizations, but allows more stability in output image quality. Disabled by default.</value>
        [JsonPropertyName("forceReadMrzBeforeLocate")]
        public bool? ForceReadMrzBeforeLocate { get { return this.ForceReadMrzBeforeLocateOption; } set { this.ForceReadMrzBeforeLocateOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of ParseBarcodes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ParseBarcodesOption { get; private set; }

        /// <summary>
        /// This option can be disabled to stop parsing after barcode is read. Enabled by default.
        /// </summary>
        /// <value>This option can be disabled to stop parsing after barcode is read. Enabled by default.</value>
        [JsonPropertyName("parseBarcodes")]
        public bool? ParseBarcodes { get { return this.ParseBarcodesOption; } set { this.ParseBarcodesOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of SplitNames
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> SplitNamesOption { get; private set; }

        /// <summary>
        /// When enabled, the Surname and GivenNames fields from MRZ will be divided into ft_First_Name, ft_Second_Name, ft_Third_Name, ft_Fourth_Name, ft_Last_Name fields. Disabled by default.
        /// </summary>
        /// <value>When enabled, the Surname and GivenNames fields from MRZ will be divided into ft_First_Name, ft_Second_Name, ft_Third_Name, ft_Fourth_Name, ft_Last_Name fields. Disabled by default.</value>
        [JsonPropertyName("splitNames")]
        public bool? SplitNames { get { return this.SplitNamesOption; } set { this.SplitNamesOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of DisablePerforationOCR
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> DisablePerforationOCROption { get; private set; }

        /// <summary>
        /// When enabled, OCR of perforated fields in the document template will not be performed. Disabled by default.
        /// </summary>
        /// <value>When enabled, OCR of perforated fields in the document template will not be performed. Disabled by default.</value>
        [JsonPropertyName("disablePerforationOCR")]
        public bool? DisablePerforationOCR { get { return this.DisablePerforationOCROption; } set { this.DisablePerforationOCROption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of DocumentGroupFilter
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<DocumentType>?> DocumentGroupFilterOption { get; private set; }

        /// <summary>
        /// List of specific eligible document types from DocumentType enum to recognize from. You may, for example, specify only passports to be recognized by setting this property. Empty by default.
        /// </summary>
        /// <value>List of specific eligible document types from DocumentType enum to recognize from. You may, for example, specify only passports to be recognized by setting this property. Empty by default.</value>
        [JsonPropertyName("documentGroupFilter")]
        public List<DocumentType>? DocumentGroupFilter { get { return this.DocumentGroupFilterOption; } set { this.DocumentGroupFilterOption = new Option<List<DocumentType>?>(value); } }

        /// <summary>
        /// Used to track the state of ProcessAuth
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> ProcessAuthOption { get; private set; }

        /// <summary>
        /// Authenticity checks that should be performed regardless of the document type. The available checks are listed in the eRPRM_Authenticity enum. Note that only supported by your license checks can be added. 
        /// </summary>
        /// <value>Authenticity checks that should be performed regardless of the document type. The available checks are listed in the eRPRM_Authenticity enum. Note that only supported by your license checks can be added. </value>
        [JsonPropertyName("processAuth")]
        public long? ProcessAuth { get { return this.ProcessAuthOption; } set { this.ProcessAuthOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of DeviceId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> DeviceIdOption { get; private set; }

        /// <summary>
        /// This parameter is used to specify the document reader device type from which input images were captured. Default 0.
        /// </summary>
        /// <value>This parameter is used to specify the document reader device type from which input images were captured. Default 0.</value>
        [JsonPropertyName("deviceId")]
        public int? DeviceId { get { return this.DeviceIdOption; } set { this.DeviceIdOption = new Option<int?>(value); } }

        /// <summary>
        /// Used to track the state of DeviceType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> DeviceTypeOption { get; private set; }

        /// <summary>
        /// This parameter is used to specify the document reader device type from which input images were captured. Default 0.
        /// </summary>
        /// <value>This parameter is used to specify the document reader device type from which input images were captured. Default 0.</value>
        [JsonPropertyName("deviceType")]
        public int? DeviceType { get { return this.DeviceTypeOption; } set { this.DeviceTypeOption = new Option<int?>(value); } }

        /// <summary>
        /// Used to track the state of DeviceTypeHex
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DeviceTypeHexOption { get; private set; }

        /// <summary>
        /// This parameter is used to specify the document reader device type from which input images were captured
        /// </summary>
        /// <value>This parameter is used to specify the document reader device type from which input images were captured</value>
        [JsonPropertyName("deviceTypeHex")]
        public string? DeviceTypeHex { get { return this.DeviceTypeHexOption; } set { this.DeviceTypeHexOption = new Option<string?>(value); } }

        /// <summary>
        /// Used to track the state of IgnoreDeviceIdFromImage
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IgnoreDeviceIdFromImageOption { get; private set; }

        /// <summary>
        /// This parameter is used to tell the processing engine to ignore any parameters saved in the image when scanned from the document reader device. Default false
        /// </summary>
        /// <value>This parameter is used to tell the processing engine to ignore any parameters saved in the image when scanned from the document reader device. Default false</value>
        [JsonPropertyName("ignoreDeviceIdFromImage")]
        public bool? IgnoreDeviceIdFromImage { get { return this.IgnoreDeviceIdFromImageOption; } set { this.IgnoreDeviceIdFromImageOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of DocumentIdList
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<int>?> DocumentIdListOption { get; private set; }

        /// <summary>
        /// List of the document ID&#39;s to process. All documents will be processed, if empty.
        /// </summary>
        /// <value>List of the document ID&#39;s to process. All documents will be processed, if empty.</value>
        [JsonPropertyName("documentIdList")]
        public List<int>? DocumentIdList { get { return this.DocumentIdListOption; } set { this.DocumentIdListOption = new Option<List<int>?>(value); } }

        /// <summary>
        /// Used to track the state of Rfid
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ProcessParamsRfid?> RfidOption { get; private set; }

        /// <summary>
        /// Gets or Sets Rfid
        /// </summary>
        [JsonPropertyName("rfid")]
        public ProcessParamsRfid? Rfid { get { return this.RfidOption; } set { this.RfidOption = new Option<ProcessParamsRfid?>(value); } }

        /// <summary>
        /// Used to track the state of CheckAuth
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> CheckAuthOption { get; private set; }

        /// <summary>
        /// This parameter is used to enable authenticity checks
        /// </summary>
        /// <value>This parameter is used to enable authenticity checks</value>
        [JsonPropertyName("checkAuth")]
        public bool? CheckAuth { get { return this.CheckAuthOption; } set { this.CheckAuthOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of AuthParams
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AuthParams?> AuthParamsOption { get; private set; }

        /// <summary>
        /// Gets or Sets AuthParams
        /// </summary>
        [JsonPropertyName("authParams")]
        public AuthParams? AuthParams { get { return this.AuthParamsOption; } set { this.AuthParamsOption = new Option<AuthParams?>(value); } }

        /// <summary>
        /// Used to track the state of GenerateNumericCodes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> GenerateNumericCodesOption { get; private set; }

        /// <summary>
        /// This parameter is used to generate numeric representation for issuing state and nationality codes
        /// </summary>
        /// <value>This parameter is used to generate numeric representation for issuing state and nationality codes</value>
        [JsonPropertyName("generateNumericCodes")]
        public bool? GenerateNumericCodes { get { return this.GenerateNumericCodesOption; } set { this.GenerateNumericCodesOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of StrictBarcodeDigitalSignatureCheck
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> StrictBarcodeDigitalSignatureCheckOption { get; private set; }

        /// <summary>
        /// This parameter if enabled will require all necessary certificates to verify digital signature in barcode data to be present in order for the Barcode format check to succeed.
        /// </summary>
        /// <value>This parameter if enabled will require all necessary certificates to verify digital signature in barcode data to be present in order for the Barcode format check to succeed.</value>
        [JsonPropertyName("strictBarcodeDigitalSignatureCheck")]
        public bool? StrictBarcodeDigitalSignatureCheck { get { return this.StrictBarcodeDigitalSignatureCheckOption; } set { this.StrictBarcodeDigitalSignatureCheckOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of SelectLongestNames
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> SelectLongestNamesOption { get; private set; }

        /// <summary>
        /// Select the longest value from the different value sources and write it to the value field if comparison is done successfully. The parameter applies this logic to the personal names, such as given name, surname, surname and given name, middle name and etc.
        /// </summary>
        /// <value>Select the longest value from the different value sources and write it to the value field if comparison is done successfully. The parameter applies this logic to the personal names, such as given name, surname, surname and given name, middle name and etc.</value>
        [JsonPropertyName("selectLongestNames")]
        public bool? SelectLongestNames { get { return this.SelectLongestNamesOption; } set { this.SelectLongestNamesOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of DoBarcodes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<InputBarcodeType>?> DoBarcodesOption { get; private set; }

        /// <summary>
        /// Set the types of barcodes to process.
        /// </summary>
        /// <value>Set the types of barcodes to process.</value>
        [JsonPropertyName("doBarcodes")]
        public List<InputBarcodeType>? DoBarcodes { get { return this.DoBarcodesOption; } set { this.DoBarcodesOption = new Option<List<InputBarcodeType>?>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ProcessParams {\n");
            sb.Append("  Scenario: ").Append(Scenario).Append("\n");
            sb.Append("  GenerateDTCVC: ").Append(GenerateDTCVC).Append("\n");
            sb.Append("  LcidFilter: ").Append(LcidFilter).Append("\n");
            sb.Append("  CheckLiveness: ").Append(CheckLiveness).Append("\n");
            sb.Append("  LcidIgnoreFilter: ").Append(LcidIgnoreFilter).Append("\n");
            sb.Append("  OneShotIdentification: ").Append(OneShotIdentification).Append("\n");
            sb.Append("  UseFaceApi: ").Append(UseFaceApi).Append("\n");
            sb.Append("  FaceApi: ").Append(FaceApi).Append("\n");
            sb.Append("  DoDetectCan: ").Append(DoDetectCan).Append("\n");
            sb.Append("  ImageOutputMaxHeight: ").Append(ImageOutputMaxHeight).Append("\n");
            sb.Append("  ImageOutputMaxWidth: ").Append(ImageOutputMaxWidth).Append("\n");
            sb.Append("  ResultTypeOutput: ").Append(ResultTypeOutput).Append("\n");
            sb.Append("  DoublePageSpread: ").Append(DoublePageSpread).Append("\n");
            sb.Append("  GenerateDoublePageSpreadImage: ").Append(GenerateDoublePageSpreadImage).Append("\n");
            sb.Append("  FieldTypesFilter: ").Append(FieldTypesFilter).Append("\n");
            sb.Append("  DateFormat: ").Append(DateFormat).Append("\n");
            sb.Append("  MeasureSystem: ").Append(MeasureSystem).Append("\n");
            sb.Append("  ImageDpiOutMax: ").Append(ImageDpiOutMax).Append("\n");
            sb.Append("  AlreadyCropped: ").Append(AlreadyCropped).Append("\n");
            sb.Append("  CustomParams: ").Append(CustomParams).Append("\n");
            sb.Append("  Config: ").Append(Config).Append("\n");
            sb.Append("  Log: ").Append(Log).Append("\n");
            sb.Append("  LogLevel: ").Append(LogLevel).Append("\n");
            sb.Append("  ForceDocID: ").Append(ForceDocID).Append("\n");
            sb.Append("  MatchTextFieldMask: ").Append(MatchTextFieldMask).Append("\n");
            sb.Append("  FastDocDetect: ").Append(FastDocDetect).Append("\n");
            sb.Append("  UpdateOCRValidityByGlare: ").Append(UpdateOCRValidityByGlare).Append("\n");
            sb.Append("  CheckRequiredTextFields: ").Append(CheckRequiredTextFields).Append("\n");
            sb.Append("  ReturnCroppedBarcode: ").Append(ReturnCroppedBarcode).Append("\n");
            sb.Append("  ImageQa: ").Append(ImageQa).Append("\n");
            sb.Append("  StrictImageQuality: ").Append(StrictImageQuality).Append("\n");
            sb.Append("  RespectImageQuality: ").Append(RespectImageQuality).Append("\n");
            sb.Append("  ForceDocFormat: ").Append(ForceDocFormat).Append("\n");
            sb.Append("  NoGraphics: ").Append(NoGraphics).Append("\n");
            sb.Append("  DepersonalizeLog: ").Append(DepersonalizeLog).Append("\n");
            sb.Append("  MultiDocOnImage: ").Append(MultiDocOnImage).Append("\n");
            sb.Append("  ShiftExpiryDate: ").Append(ShiftExpiryDate).Append("\n");
            sb.Append("  MinimalHolderAge: ").Append(MinimalHolderAge).Append("\n");
            sb.Append("  ReturnUncroppedImage: ").Append(ReturnUncroppedImage).Append("\n");
            sb.Append("  MrzFormatsFilter: ").Append(MrzFormatsFilter).Append("\n");
            sb.Append("  ForceReadMrzBeforeLocate: ").Append(ForceReadMrzBeforeLocate).Append("\n");
            sb.Append("  ParseBarcodes: ").Append(ParseBarcodes).Append("\n");
            sb.Append("  ConvertCase: ").Append(ConvertCase).Append("\n");
            sb.Append("  SplitNames: ").Append(SplitNames).Append("\n");
            sb.Append("  DisablePerforationOCR: ").Append(DisablePerforationOCR).Append("\n");
            sb.Append("  DocumentGroupFilter: ").Append(DocumentGroupFilter).Append("\n");
            sb.Append("  ProcessAuth: ").Append(ProcessAuth).Append("\n");
            sb.Append("  DeviceId: ").Append(DeviceId).Append("\n");
            sb.Append("  DeviceType: ").Append(DeviceType).Append("\n");
            sb.Append("  DeviceTypeHex: ").Append(DeviceTypeHex).Append("\n");
            sb.Append("  IgnoreDeviceIdFromImage: ").Append(IgnoreDeviceIdFromImage).Append("\n");
            sb.Append("  DocumentIdList: ").Append(DocumentIdList).Append("\n");
            sb.Append("  Rfid: ").Append(Rfid).Append("\n");
            sb.Append("  CheckAuth: ").Append(CheckAuth).Append("\n");
            sb.Append("  AuthParams: ").Append(AuthParams).Append("\n");
            sb.Append("  MrzDetectMode: ").Append(MrzDetectMode).Append("\n");
            sb.Append("  GenerateNumericCodes: ").Append(GenerateNumericCodes).Append("\n");
            sb.Append("  StrictBarcodeDigitalSignatureCheck: ").Append(StrictBarcodeDigitalSignatureCheck).Append("\n");
            sb.Append("  SelectLongestNames: ").Append(SelectLongestNames).Append("\n");
            sb.Append("  DoBarcodes: ").Append(DoBarcodes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="ProcessParams" />
    /// </summary>
    public class ProcessParamsJsonConverter : JsonConverter<ProcessParams>
    {
        /// <summary>
        /// Deserializes json to <see cref="ProcessParams" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override ProcessParams Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Scenario?> scenario = default;
            Option<bool?> generateDTCVC = default;
            Option<List<LCID>?> lcidFilter = default;
            Option<bool?> checkLiveness = default;
            Option<List<LCID>?> lcidIgnoreFilter = default;
            Option<bool?> oneShotIdentification = default;
            Option<bool?> useFaceApi = default;
            Option<FaceApi?> faceApi = default;
            Option<bool?> doDetectCan = default;
            Option<int?> imageOutputMaxHeight = default;
            Option<int?> imageOutputMaxWidth = default;
            Option<List<Result>?> resultTypeOutput = default;
            Option<bool?> doublePageSpread = default;
            Option<bool?> generateDoublePageSpreadImage = default;
            Option<List<TextFieldType>?> fieldTypesFilter = default;
            Option<string?> dateFormat = default;
            Option<MeasureSystem?> measureSystem = default;
            Option<int?> imageDpiOutMax = default;
            Option<bool?> alreadyCropped = default;
            Option<Dictionary<string, Object>?> customParams = default;
            Option<List<PerDocumentConfig>?> config = default;
            Option<bool?> log = default;
            Option<LogLevel?> logLevel = default;
            Option<int?> forceDocID = default;
            Option<bool?> matchTextFieldMask = default;
            Option<bool?> fastDocDetect = default;
            Option<bool?> updateOCRValidityByGlare = default;
            Option<bool?> checkRequiredTextFields = default;
            Option<bool?> returnCroppedBarcode = default;
            Option<ImageQA?> imageQa = default;
            Option<bool?> strictImageQuality = default;
            Option<bool?> respectImageQuality = default;
            Option<DocumentFormat?> forceDocFormat = default;
            Option<bool?> noGraphics = default;
            Option<bool?> depersonalizeLog = default;
            Option<bool?> multiDocOnImage = default;
            Option<int?> shiftExpiryDate = default;
            Option<int?> minimalHolderAge = default;
            Option<bool?> returnUncroppedImage = default;
            Option<List<MRZFormat>?> mrzFormatsFilter = default;
            Option<bool?> forceReadMrzBeforeLocate = default;
            Option<bool?> parseBarcodes = default;
            Option<TextPostProcessing?> convertCase = default;
            Option<bool?> splitNames = default;
            Option<bool?> disablePerforationOCR = default;
            Option<List<DocumentType>?> documentGroupFilter = default;
            Option<long?> processAuth = default;
            Option<int?> deviceId = default;
            Option<int?> deviceType = default;
            Option<string?> deviceTypeHex = default;
            Option<bool?> ignoreDeviceIdFromImage = default;
            Option<List<int>?> documentIdList = default;
            Option<ProcessParamsRfid?> rfid = default;
            Option<bool?> checkAuth = default;
            Option<AuthParams?> authParams = default;
            Option<MrzDetectModeEnum?> mrzDetectMode = default;
            Option<bool?> generateNumericCodes = default;
            Option<bool?> strictBarcodeDigitalSignatureCheck = default;
            Option<bool?> selectLongestNames = default;
            Option<List<InputBarcodeType>?> doBarcodes = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "scenario":
                            string? scenarioRawValue = utf8JsonReader.GetString();
                            if (scenarioRawValue != null)
                                scenario = new Option<Scenario?>(ScenarioValueConverter.FromStringOrDefault(scenarioRawValue));
                            break;
                        case "generateDTCVC":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                generateDTCVC = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "lcidFilter":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                lcidFilter = new Option<List<LCID>?>(JsonSerializer.Deserialize<List<LCID>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "checkLiveness":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                checkLiveness = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "lcidIgnoreFilter":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                lcidIgnoreFilter = new Option<List<LCID>?>(JsonSerializer.Deserialize<List<LCID>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "oneShotIdentification":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                oneShotIdentification = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "useFaceApi":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                useFaceApi = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "faceApi":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                faceApi = new Option<FaceApi?>(JsonSerializer.Deserialize<FaceApi>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "doDetectCan":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                doDetectCan = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "imageOutputMaxHeight":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                imageOutputMaxHeight = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "imageOutputMaxWidth":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                imageOutputMaxWidth = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "resultTypeOutput":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                resultTypeOutput = new Option<List<Result>?>(JsonSerializer.Deserialize<List<Result>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "doublePageSpread":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                doublePageSpread = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "generateDoublePageSpreadImage":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                generateDoublePageSpreadImage = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "fieldTypesFilter":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                fieldTypesFilter = new Option<List<TextFieldType>?>(JsonSerializer.Deserialize<List<TextFieldType>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "dateFormat":
                            dateFormat = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "measureSystem":
                            string? measureSystemRawValue = utf8JsonReader.GetString();
                            if (measureSystemRawValue != null)
                                measureSystem = new Option<MeasureSystem?>(MeasureSystemValueConverter.FromStringOrDefault(measureSystemRawValue));
                            break;
                        case "imageDpiOutMax":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                imageDpiOutMax = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "alreadyCropped":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                alreadyCropped = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "customParams":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                customParams = new Option<Dictionary<string, Object>?>(JsonSerializer.Deserialize<Dictionary<string, Object>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "config":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                config = new Option<List<PerDocumentConfig>?>(JsonSerializer.Deserialize<List<PerDocumentConfig>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "log":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                log = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "logLevel":
                            string? logLevelRawValue = utf8JsonReader.GetString();
                            if (logLevelRawValue != null)
                                logLevel = new Option<LogLevel?>(LogLevelValueConverter.FromStringOrDefault(logLevelRawValue));
                            break;
                        case "forceDocID":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                forceDocID = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "matchTextFieldMask":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                matchTextFieldMask = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "fastDocDetect":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                fastDocDetect = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "updateOCRValidityByGlare":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                updateOCRValidityByGlare = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "checkRequiredTextFields":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                checkRequiredTextFields = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "returnCroppedBarcode":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                returnCroppedBarcode = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "imageQa":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                imageQa = new Option<ImageQA?>(JsonSerializer.Deserialize<ImageQA>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "strictImageQuality":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                strictImageQuality = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "respectImageQuality":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                respectImageQuality = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "forceDocFormat":
                            string? forceDocFormatRawValue = utf8JsonReader.GetString();
                            if (forceDocFormatRawValue != null)
                                forceDocFormat = new Option<DocumentFormat?>(DocumentFormatValueConverter.FromStringOrDefault(forceDocFormatRawValue));
                            break;
                        case "noGraphics":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                noGraphics = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "depersonalizeLog":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                depersonalizeLog = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "multiDocOnImage":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                multiDocOnImage = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "shiftExpiryDate":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                shiftExpiryDate = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "minimalHolderAge":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                minimalHolderAge = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "returnUncroppedImage":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                returnUncroppedImage = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "mrzFormatsFilter":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                mrzFormatsFilter = new Option<List<MRZFormat>?>(JsonSerializer.Deserialize<List<MRZFormat>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "forceReadMrzBeforeLocate":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                forceReadMrzBeforeLocate = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "parseBarcodes":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                parseBarcodes = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "convertCase":
                            string? convertCaseRawValue = utf8JsonReader.GetString();
                            if (convertCaseRawValue != null)
                                convertCase = new Option<TextPostProcessing?>(TextPostProcessingValueConverter.FromStringOrDefault(convertCaseRawValue));
                            break;
                        case "splitNames":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                splitNames = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "disablePerforationOCR":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                disablePerforationOCR = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "documentGroupFilter":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                documentGroupFilter = new Option<List<DocumentType>?>(JsonSerializer.Deserialize<List<DocumentType>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "processAuth":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                processAuth = new Option<long?>(utf8JsonReader.GetInt64());
                            break;
                        case "deviceId":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                deviceId = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "deviceType":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                deviceType = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "deviceTypeHex":
                            deviceTypeHex = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "ignoreDeviceIdFromImage":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                ignoreDeviceIdFromImage = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "documentIdList":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                documentIdList = new Option<List<int>?>(JsonSerializer.Deserialize<List<int>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "rfid":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                rfid = new Option<ProcessParamsRfid?>(JsonSerializer.Deserialize<ProcessParamsRfid>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "checkAuth":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                checkAuth = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "authParams":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                authParams = new Option<AuthParams?>(JsonSerializer.Deserialize<AuthParams>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "mrzDetectMode":
                            string? mrzDetectModeRawValue = utf8JsonReader.GetString();
                            if (mrzDetectModeRawValue != null)
                                mrzDetectMode = new Option<MrzDetectModeEnum?>(MrzDetectModeEnumValueConverter.FromStringOrDefault(mrzDetectModeRawValue));
                            break;
                        case "generateNumericCodes":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                generateNumericCodes = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "strictBarcodeDigitalSignatureCheck":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                strictBarcodeDigitalSignatureCheck = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "selectLongestNames":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                selectLongestNames = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "doBarcodes":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                doBarcodes = new Option<List<InputBarcodeType>?>(JsonSerializer.Deserialize<List<InputBarcodeType>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!scenario.IsSet)
                throw new ArgumentException("Property is required for class ProcessParams.", nameof(scenario));

            if (scenario.IsSet && scenario.Value == null)
                throw new ArgumentNullException(nameof(scenario), "Property is not nullable for class ProcessParams.");

            if (generateDTCVC.IsSet && generateDTCVC.Value == null)
                throw new ArgumentNullException(nameof(generateDTCVC), "Property is not nullable for class ProcessParams.");

            if (lcidFilter.IsSet && lcidFilter.Value == null)
                throw new ArgumentNullException(nameof(lcidFilter), "Property is not nullable for class ProcessParams.");

            if (checkLiveness.IsSet && checkLiveness.Value == null)
                throw new ArgumentNullException(nameof(checkLiveness), "Property is not nullable for class ProcessParams.");

            if (lcidIgnoreFilter.IsSet && lcidIgnoreFilter.Value == null)
                throw new ArgumentNullException(nameof(lcidIgnoreFilter), "Property is not nullable for class ProcessParams.");

            if (oneShotIdentification.IsSet && oneShotIdentification.Value == null)
                throw new ArgumentNullException(nameof(oneShotIdentification), "Property is not nullable for class ProcessParams.");

            if (useFaceApi.IsSet && useFaceApi.Value == null)
                throw new ArgumentNullException(nameof(useFaceApi), "Property is not nullable for class ProcessParams.");

            if (faceApi.IsSet && faceApi.Value == null)
                throw new ArgumentNullException(nameof(faceApi), "Property is not nullable for class ProcessParams.");

            if (doDetectCan.IsSet && doDetectCan.Value == null)
                throw new ArgumentNullException(nameof(doDetectCan), "Property is not nullable for class ProcessParams.");

            if (imageOutputMaxHeight.IsSet && imageOutputMaxHeight.Value == null)
                throw new ArgumentNullException(nameof(imageOutputMaxHeight), "Property is not nullable for class ProcessParams.");

            if (imageOutputMaxWidth.IsSet && imageOutputMaxWidth.Value == null)
                throw new ArgumentNullException(nameof(imageOutputMaxWidth), "Property is not nullable for class ProcessParams.");

            if (resultTypeOutput.IsSet && resultTypeOutput.Value == null)
                throw new ArgumentNullException(nameof(resultTypeOutput), "Property is not nullable for class ProcessParams.");

            if (doublePageSpread.IsSet && doublePageSpread.Value == null)
                throw new ArgumentNullException(nameof(doublePageSpread), "Property is not nullable for class ProcessParams.");

            if (generateDoublePageSpreadImage.IsSet && generateDoublePageSpreadImage.Value == null)
                throw new ArgumentNullException(nameof(generateDoublePageSpreadImage), "Property is not nullable for class ProcessParams.");

            if (fieldTypesFilter.IsSet && fieldTypesFilter.Value == null)
                throw new ArgumentNullException(nameof(fieldTypesFilter), "Property is not nullable for class ProcessParams.");

            if (dateFormat.IsSet && dateFormat.Value == null)
                throw new ArgumentNullException(nameof(dateFormat), "Property is not nullable for class ProcessParams.");

            if (measureSystem.IsSet && measureSystem.Value == null)
                throw new ArgumentNullException(nameof(measureSystem), "Property is not nullable for class ProcessParams.");

            if (imageDpiOutMax.IsSet && imageDpiOutMax.Value == null)
                throw new ArgumentNullException(nameof(imageDpiOutMax), "Property is not nullable for class ProcessParams.");

            if (alreadyCropped.IsSet && alreadyCropped.Value == null)
                throw new ArgumentNullException(nameof(alreadyCropped), "Property is not nullable for class ProcessParams.");

            if (customParams.IsSet && customParams.Value == null)
                throw new ArgumentNullException(nameof(customParams), "Property is not nullable for class ProcessParams.");

            if (config.IsSet && config.Value == null)
                throw new ArgumentNullException(nameof(config), "Property is not nullable for class ProcessParams.");

            if (log.IsSet && log.Value == null)
                throw new ArgumentNullException(nameof(log), "Property is not nullable for class ProcessParams.");

            if (logLevel.IsSet && logLevel.Value == null)
                throw new ArgumentNullException(nameof(logLevel), "Property is not nullable for class ProcessParams.");

            if (forceDocID.IsSet && forceDocID.Value == null)
                throw new ArgumentNullException(nameof(forceDocID), "Property is not nullable for class ProcessParams.");

            if (matchTextFieldMask.IsSet && matchTextFieldMask.Value == null)
                throw new ArgumentNullException(nameof(matchTextFieldMask), "Property is not nullable for class ProcessParams.");

            if (fastDocDetect.IsSet && fastDocDetect.Value == null)
                throw new ArgumentNullException(nameof(fastDocDetect), "Property is not nullable for class ProcessParams.");

            if (updateOCRValidityByGlare.IsSet && updateOCRValidityByGlare.Value == null)
                throw new ArgumentNullException(nameof(updateOCRValidityByGlare), "Property is not nullable for class ProcessParams.");

            if (checkRequiredTextFields.IsSet && checkRequiredTextFields.Value == null)
                throw new ArgumentNullException(nameof(checkRequiredTextFields), "Property is not nullable for class ProcessParams.");

            if (returnCroppedBarcode.IsSet && returnCroppedBarcode.Value == null)
                throw new ArgumentNullException(nameof(returnCroppedBarcode), "Property is not nullable for class ProcessParams.");

            if (imageQa.IsSet && imageQa.Value == null)
                throw new ArgumentNullException(nameof(imageQa), "Property is not nullable for class ProcessParams.");

            if (strictImageQuality.IsSet && strictImageQuality.Value == null)
                throw new ArgumentNullException(nameof(strictImageQuality), "Property is not nullable for class ProcessParams.");

            if (respectImageQuality.IsSet && respectImageQuality.Value == null)
                throw new ArgumentNullException(nameof(respectImageQuality), "Property is not nullable for class ProcessParams.");

            if (forceDocFormat.IsSet && forceDocFormat.Value == null)
                throw new ArgumentNullException(nameof(forceDocFormat), "Property is not nullable for class ProcessParams.");

            if (noGraphics.IsSet && noGraphics.Value == null)
                throw new ArgumentNullException(nameof(noGraphics), "Property is not nullable for class ProcessParams.");

            if (depersonalizeLog.IsSet && depersonalizeLog.Value == null)
                throw new ArgumentNullException(nameof(depersonalizeLog), "Property is not nullable for class ProcessParams.");

            if (multiDocOnImage.IsSet && multiDocOnImage.Value == null)
                throw new ArgumentNullException(nameof(multiDocOnImage), "Property is not nullable for class ProcessParams.");

            if (shiftExpiryDate.IsSet && shiftExpiryDate.Value == null)
                throw new ArgumentNullException(nameof(shiftExpiryDate), "Property is not nullable for class ProcessParams.");

            if (minimalHolderAge.IsSet && minimalHolderAge.Value == null)
                throw new ArgumentNullException(nameof(minimalHolderAge), "Property is not nullable for class ProcessParams.");

            if (returnUncroppedImage.IsSet && returnUncroppedImage.Value == null)
                throw new ArgumentNullException(nameof(returnUncroppedImage), "Property is not nullable for class ProcessParams.");

            if (mrzFormatsFilter.IsSet && mrzFormatsFilter.Value == null)
                throw new ArgumentNullException(nameof(mrzFormatsFilter), "Property is not nullable for class ProcessParams.");

            if (forceReadMrzBeforeLocate.IsSet && forceReadMrzBeforeLocate.Value == null)
                throw new ArgumentNullException(nameof(forceReadMrzBeforeLocate), "Property is not nullable for class ProcessParams.");

            if (parseBarcodes.IsSet && parseBarcodes.Value == null)
                throw new ArgumentNullException(nameof(parseBarcodes), "Property is not nullable for class ProcessParams.");

            if (convertCase.IsSet && convertCase.Value == null)
                throw new ArgumentNullException(nameof(convertCase), "Property is not nullable for class ProcessParams.");

            if (splitNames.IsSet && splitNames.Value == null)
                throw new ArgumentNullException(nameof(splitNames), "Property is not nullable for class ProcessParams.");

            if (disablePerforationOCR.IsSet && disablePerforationOCR.Value == null)
                throw new ArgumentNullException(nameof(disablePerforationOCR), "Property is not nullable for class ProcessParams.");

            if (documentGroupFilter.IsSet && documentGroupFilter.Value == null)
                throw new ArgumentNullException(nameof(documentGroupFilter), "Property is not nullable for class ProcessParams.");

            if (processAuth.IsSet && processAuth.Value == null)
                throw new ArgumentNullException(nameof(processAuth), "Property is not nullable for class ProcessParams.");

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId), "Property is not nullable for class ProcessParams.");

            if (deviceType.IsSet && deviceType.Value == null)
                throw new ArgumentNullException(nameof(deviceType), "Property is not nullable for class ProcessParams.");

            if (deviceTypeHex.IsSet && deviceTypeHex.Value == null)
                throw new ArgumentNullException(nameof(deviceTypeHex), "Property is not nullable for class ProcessParams.");

            if (ignoreDeviceIdFromImage.IsSet && ignoreDeviceIdFromImage.Value == null)
                throw new ArgumentNullException(nameof(ignoreDeviceIdFromImage), "Property is not nullable for class ProcessParams.");

            if (documentIdList.IsSet && documentIdList.Value == null)
                throw new ArgumentNullException(nameof(documentIdList), "Property is not nullable for class ProcessParams.");

            if (rfid.IsSet && rfid.Value == null)
                throw new ArgumentNullException(nameof(rfid), "Property is not nullable for class ProcessParams.");

            if (checkAuth.IsSet && checkAuth.Value == null)
                throw new ArgumentNullException(nameof(checkAuth), "Property is not nullable for class ProcessParams.");

            if (authParams.IsSet && authParams.Value == null)
                throw new ArgumentNullException(nameof(authParams), "Property is not nullable for class ProcessParams.");

            if (mrzDetectMode.IsSet && mrzDetectMode.Value == null)
                throw new ArgumentNullException(nameof(mrzDetectMode), "Property is not nullable for class ProcessParams.");

            if (generateNumericCodes.IsSet && generateNumericCodes.Value == null)
                throw new ArgumentNullException(nameof(generateNumericCodes), "Property is not nullable for class ProcessParams.");

            if (strictBarcodeDigitalSignatureCheck.IsSet && strictBarcodeDigitalSignatureCheck.Value == null)
                throw new ArgumentNullException(nameof(strictBarcodeDigitalSignatureCheck), "Property is not nullable for class ProcessParams.");

            if (selectLongestNames.IsSet && selectLongestNames.Value == null)
                throw new ArgumentNullException(nameof(selectLongestNames), "Property is not nullable for class ProcessParams.");

            if (doBarcodes.IsSet && doBarcodes.Value == null)
                throw new ArgumentNullException(nameof(doBarcodes), "Property is not nullable for class ProcessParams.");

            return new ProcessParams(scenario.Value!.Value!, generateDTCVC, lcidFilter, checkLiveness, lcidIgnoreFilter, oneShotIdentification, useFaceApi, faceApi, doDetectCan, imageOutputMaxHeight, imageOutputMaxWidth, resultTypeOutput, doublePageSpread, generateDoublePageSpreadImage, fieldTypesFilter, dateFormat, measureSystem, imageDpiOutMax, alreadyCropped, customParams, config, log, logLevel, forceDocID, matchTextFieldMask, fastDocDetect, updateOCRValidityByGlare, checkRequiredTextFields, returnCroppedBarcode, imageQa, strictImageQuality, respectImageQuality, forceDocFormat, noGraphics, depersonalizeLog, multiDocOnImage, shiftExpiryDate, minimalHolderAge, returnUncroppedImage, mrzFormatsFilter, forceReadMrzBeforeLocate, parseBarcodes, convertCase, splitNames, disablePerforationOCR, documentGroupFilter, processAuth, deviceId, deviceType, deviceTypeHex, ignoreDeviceIdFromImage, documentIdList, rfid, checkAuth, authParams, mrzDetectMode, generateNumericCodes, strictBarcodeDigitalSignatureCheck, selectLongestNames, doBarcodes);
        }

        /// <summary>
        /// Serializes a <see cref="ProcessParams" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="processParams"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, ProcessParams processParams, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, processParams, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="ProcessParams" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="processParams"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, ProcessParams processParams, JsonSerializerOptions jsonSerializerOptions)
        {
            if (processParams.LcidFilterOption.IsSet && processParams.LcidFilter == null)
                throw new ArgumentNullException(nameof(processParams.LcidFilter), "Property is required for class ProcessParams.");

            if (processParams.LcidIgnoreFilterOption.IsSet && processParams.LcidIgnoreFilter == null)
                throw new ArgumentNullException(nameof(processParams.LcidIgnoreFilter), "Property is required for class ProcessParams.");

            if (processParams.FaceApiOption.IsSet && processParams.FaceApi == null)
                throw new ArgumentNullException(nameof(processParams.FaceApi), "Property is required for class ProcessParams.");

            if (processParams.ResultTypeOutputOption.IsSet && processParams.ResultTypeOutput == null)
                throw new ArgumentNullException(nameof(processParams.ResultTypeOutput), "Property is required for class ProcessParams.");

            if (processParams.FieldTypesFilterOption.IsSet && processParams.FieldTypesFilter == null)
                throw new ArgumentNullException(nameof(processParams.FieldTypesFilter), "Property is required for class ProcessParams.");

            if (processParams.DateFormatOption.IsSet && processParams.DateFormat == null)
                throw new ArgumentNullException(nameof(processParams.DateFormat), "Property is required for class ProcessParams.");

            if (processParams.CustomParamsOption.IsSet && processParams.CustomParams == null)
                throw new ArgumentNullException(nameof(processParams.CustomParams), "Property is required for class ProcessParams.");

            if (processParams.ConfigOption.IsSet && processParams.Config == null)
                throw new ArgumentNullException(nameof(processParams.Config), "Property is required for class ProcessParams.");

            if (processParams.ImageQaOption.IsSet && processParams.ImageQa == null)
                throw new ArgumentNullException(nameof(processParams.ImageQa), "Property is required for class ProcessParams.");

            if (processParams.MrzFormatsFilterOption.IsSet && processParams.MrzFormatsFilter == null)
                throw new ArgumentNullException(nameof(processParams.MrzFormatsFilter), "Property is required for class ProcessParams.");

            if (processParams.DocumentGroupFilterOption.IsSet && processParams.DocumentGroupFilter == null)
                throw new ArgumentNullException(nameof(processParams.DocumentGroupFilter), "Property is required for class ProcessParams.");

            if (processParams.DeviceTypeHexOption.IsSet && processParams.DeviceTypeHex == null)
                throw new ArgumentNullException(nameof(processParams.DeviceTypeHex), "Property is required for class ProcessParams.");

            if (processParams.DocumentIdListOption.IsSet && processParams.DocumentIdList == null)
                throw new ArgumentNullException(nameof(processParams.DocumentIdList), "Property is required for class ProcessParams.");

            if (processParams.RfidOption.IsSet && processParams.Rfid == null)
                throw new ArgumentNullException(nameof(processParams.Rfid), "Property is required for class ProcessParams.");

            if (processParams.AuthParamsOption.IsSet && processParams.AuthParams == null)
                throw new ArgumentNullException(nameof(processParams.AuthParams), "Property is required for class ProcessParams.");

            if (processParams.DoBarcodesOption.IsSet && processParams.DoBarcodes == null)
                throw new ArgumentNullException(nameof(processParams.DoBarcodes), "Property is required for class ProcessParams.");

            var scenarioRawValue = ScenarioValueConverter.ToJsonValue(processParams.Scenario);
            writer.WriteString("scenario", scenarioRawValue);

            if (processParams.GenerateDTCVCOption.IsSet)
                writer.WriteBoolean("generateDTCVC", processParams.GenerateDTCVCOption.Value!.Value);

            if (processParams.LcidFilterOption.IsSet)
            {
                writer.WritePropertyName("lcidFilter");
                JsonSerializer.Serialize(writer, processParams.LcidFilter, jsonSerializerOptions);
            }
            if (processParams.CheckLivenessOption.IsSet)
                writer.WriteBoolean("checkLiveness", processParams.CheckLivenessOption.Value!.Value);

            if (processParams.LcidIgnoreFilterOption.IsSet)
            {
                writer.WritePropertyName("lcidIgnoreFilter");
                JsonSerializer.Serialize(writer, processParams.LcidIgnoreFilter, jsonSerializerOptions);
            }
            if (processParams.OneShotIdentificationOption.IsSet)
                writer.WriteBoolean("oneShotIdentification", processParams.OneShotIdentificationOption.Value!.Value);

            if (processParams.UseFaceApiOption.IsSet)
                writer.WriteBoolean("useFaceApi", processParams.UseFaceApiOption.Value!.Value);

            if (processParams.FaceApiOption.IsSet)
            {
                writer.WritePropertyName("faceApi");
                JsonSerializer.Serialize(writer, processParams.FaceApi, jsonSerializerOptions);
            }
            if (processParams.DoDetectCanOption.IsSet)
                writer.WriteBoolean("doDetectCan", processParams.DoDetectCanOption.Value!.Value);

            if (processParams.ImageOutputMaxHeightOption.IsSet)
                writer.WriteNumber("imageOutputMaxHeight", processParams.ImageOutputMaxHeightOption.Value!.Value);

            if (processParams.ImageOutputMaxWidthOption.IsSet)
                writer.WriteNumber("imageOutputMaxWidth", processParams.ImageOutputMaxWidthOption.Value!.Value);

            if (processParams.ResultTypeOutputOption.IsSet)
            {
                writer.WritePropertyName("resultTypeOutput");
                JsonSerializer.Serialize(writer, processParams.ResultTypeOutput, jsonSerializerOptions);
            }
            if (processParams.DoublePageSpreadOption.IsSet)
                writer.WriteBoolean("doublePageSpread", processParams.DoublePageSpreadOption.Value!.Value);

            if (processParams.GenerateDoublePageSpreadImageOption.IsSet)
                writer.WriteBoolean("generateDoublePageSpreadImage", processParams.GenerateDoublePageSpreadImageOption.Value!.Value);

            if (processParams.FieldTypesFilterOption.IsSet)
            {
                writer.WritePropertyName("fieldTypesFilter");
                JsonSerializer.Serialize(writer, processParams.FieldTypesFilter, jsonSerializerOptions);
            }
            if (processParams.DateFormatOption.IsSet)
                writer.WriteString("dateFormat", processParams.DateFormat);

            if (processParams.MeasureSystemOption.IsSet)
            {
                var measureSystemRawValue = MeasureSystemValueConverter.ToJsonValue(processParams.MeasureSystem!.Value);
                writer.WriteNumber("measureSystem", measureSystemRawValue);
            }
            if (processParams.ImageDpiOutMaxOption.IsSet)
                writer.WriteNumber("imageDpiOutMax", processParams.ImageDpiOutMaxOption.Value!.Value);

            if (processParams.AlreadyCroppedOption.IsSet)
                writer.WriteBoolean("alreadyCropped", processParams.AlreadyCroppedOption.Value!.Value);

            if (processParams.CustomParamsOption.IsSet)
            {
                writer.WritePropertyName("customParams");
                JsonSerializer.Serialize(writer, processParams.CustomParams, jsonSerializerOptions);
            }
            if (processParams.ConfigOption.IsSet)
            {
                writer.WritePropertyName("config");
                JsonSerializer.Serialize(writer, processParams.Config, jsonSerializerOptions);
            }
            if (processParams.LogOption.IsSet)
                writer.WriteBoolean("log", processParams.LogOption.Value!.Value);

            if (processParams.LogLevelOption.IsSet)
            {
                var logLevelRawValue = LogLevelValueConverter.ToJsonValue(processParams.LogLevel!.Value);
                writer.WriteString("logLevel", logLevelRawValue);
            }
            if (processParams.ForceDocIDOption.IsSet)
                writer.WriteNumber("forceDocID", processParams.ForceDocIDOption.Value!.Value);

            if (processParams.MatchTextFieldMaskOption.IsSet)
                writer.WriteBoolean("matchTextFieldMask", processParams.MatchTextFieldMaskOption.Value!.Value);

            if (processParams.FastDocDetectOption.IsSet)
                writer.WriteBoolean("fastDocDetect", processParams.FastDocDetectOption.Value!.Value);

            if (processParams.UpdateOCRValidityByGlareOption.IsSet)
                writer.WriteBoolean("updateOCRValidityByGlare", processParams.UpdateOCRValidityByGlareOption.Value!.Value);

            if (processParams.CheckRequiredTextFieldsOption.IsSet)
                writer.WriteBoolean("checkRequiredTextFields", processParams.CheckRequiredTextFieldsOption.Value!.Value);

            if (processParams.ReturnCroppedBarcodeOption.IsSet)
                writer.WriteBoolean("returnCroppedBarcode", processParams.ReturnCroppedBarcodeOption.Value!.Value);

            if (processParams.ImageQaOption.IsSet)
            {
                writer.WritePropertyName("imageQa");
                JsonSerializer.Serialize(writer, processParams.ImageQa, jsonSerializerOptions);
            }
            if (processParams.StrictImageQualityOption.IsSet)
                writer.WriteBoolean("strictImageQuality", processParams.StrictImageQualityOption.Value!.Value);

            if (processParams.RespectImageQualityOption.IsSet)
                writer.WriteBoolean("respectImageQuality", processParams.RespectImageQualityOption.Value!.Value);

            if (processParams.ForceDocFormatOption.IsSet)
            {
                var forceDocFormatRawValue = DocumentFormatValueConverter.ToJsonValue(processParams.ForceDocFormat!.Value);
                writer.WriteNumber("forceDocFormat", forceDocFormatRawValue);
            }
            if (processParams.NoGraphicsOption.IsSet)
                writer.WriteBoolean("noGraphics", processParams.NoGraphicsOption.Value!.Value);

            if (processParams.DepersonalizeLogOption.IsSet)
                writer.WriteBoolean("depersonalizeLog", processParams.DepersonalizeLogOption.Value!.Value);

            if (processParams.MultiDocOnImageOption.IsSet)
                writer.WriteBoolean("multiDocOnImage", processParams.MultiDocOnImageOption.Value!.Value);

            if (processParams.ShiftExpiryDateOption.IsSet)
                writer.WriteNumber("shiftExpiryDate", processParams.ShiftExpiryDateOption.Value!.Value);

            if (processParams.MinimalHolderAgeOption.IsSet)
                writer.WriteNumber("minimalHolderAge", processParams.MinimalHolderAgeOption.Value!.Value);

            if (processParams.ReturnUncroppedImageOption.IsSet)
                writer.WriteBoolean("returnUncroppedImage", processParams.ReturnUncroppedImageOption.Value!.Value);

            if (processParams.MrzFormatsFilterOption.IsSet)
            {
                writer.WritePropertyName("mrzFormatsFilter");
                JsonSerializer.Serialize(writer, processParams.MrzFormatsFilter, jsonSerializerOptions);
            }
            if (processParams.ForceReadMrzBeforeLocateOption.IsSet)
                writer.WriteBoolean("forceReadMrzBeforeLocate", processParams.ForceReadMrzBeforeLocateOption.Value!.Value);

            if (processParams.ParseBarcodesOption.IsSet)
                writer.WriteBoolean("parseBarcodes", processParams.ParseBarcodesOption.Value!.Value);

            if (processParams.ConvertCaseOption.IsSet)
            {
                var convertCaseRawValue = TextPostProcessingValueConverter.ToJsonValue(processParams.ConvertCase!.Value);
                writer.WriteNumber("convertCase", convertCaseRawValue);
            }
            if (processParams.SplitNamesOption.IsSet)
                writer.WriteBoolean("splitNames", processParams.SplitNamesOption.Value!.Value);

            if (processParams.DisablePerforationOCROption.IsSet)
                writer.WriteBoolean("disablePerforationOCR", processParams.DisablePerforationOCROption.Value!.Value);

            if (processParams.DocumentGroupFilterOption.IsSet)
            {
                writer.WritePropertyName("documentGroupFilter");
                JsonSerializer.Serialize(writer, processParams.DocumentGroupFilter, jsonSerializerOptions);
            }
            if (processParams.ProcessAuthOption.IsSet)
                writer.WriteNumber("processAuth", processParams.ProcessAuthOption.Value!.Value);

            if (processParams.DeviceIdOption.IsSet)
                writer.WriteNumber("deviceId", processParams.DeviceIdOption.Value!.Value);

            if (processParams.DeviceTypeOption.IsSet)
                writer.WriteNumber("deviceType", processParams.DeviceTypeOption.Value!.Value);

            if (processParams.DeviceTypeHexOption.IsSet)
                writer.WriteString("deviceTypeHex", processParams.DeviceTypeHex);

            if (processParams.IgnoreDeviceIdFromImageOption.IsSet)
                writer.WriteBoolean("ignoreDeviceIdFromImage", processParams.IgnoreDeviceIdFromImageOption.Value!.Value);

            if (processParams.DocumentIdListOption.IsSet)
            {
                writer.WritePropertyName("documentIdList");
                JsonSerializer.Serialize(writer, processParams.DocumentIdList, jsonSerializerOptions);
            }
            if (processParams.RfidOption.IsSet)
            {
                writer.WritePropertyName("rfid");
                JsonSerializer.Serialize(writer, processParams.Rfid, jsonSerializerOptions);
            }
            if (processParams.CheckAuthOption.IsSet)
                writer.WriteBoolean("checkAuth", processParams.CheckAuthOption.Value!.Value);

            if (processParams.AuthParamsOption.IsSet)
            {
                writer.WritePropertyName("authParams");
                JsonSerializer.Serialize(writer, processParams.AuthParams, jsonSerializerOptions);
            }
            if (processParams.MrzDetectModeOption.IsSet)
            {
                var mrzDetectModeRawValue = MrzDetectModeEnumValueConverter.ToJsonValue(processParams.MrzDetectMode!.Value);
                writer.WriteNumber("mrzDetectMode", mrzDetectModeRawValue);
            }
            if (processParams.GenerateNumericCodesOption.IsSet)
                writer.WriteBoolean("generateNumericCodes", processParams.GenerateNumericCodesOption.Value!.Value);

            if (processParams.StrictBarcodeDigitalSignatureCheckOption.IsSet)
                writer.WriteBoolean("strictBarcodeDigitalSignatureCheck", processParams.StrictBarcodeDigitalSignatureCheckOption.Value!.Value);

            if (processParams.SelectLongestNamesOption.IsSet)
                writer.WriteBoolean("selectLongestNames", processParams.SelectLongestNamesOption.Value!.Value);

            if (processParams.DoBarcodesOption.IsSet)
            {
                writer.WritePropertyName("doBarcodes");
                JsonSerializer.Serialize(writer, processParams.DoBarcodes, jsonSerializerOptions);
            }
        }
    }
}
