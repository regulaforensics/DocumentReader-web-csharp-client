// <auto-generated>
/*
 * Regula Document Reader Web API
 *
 * Documents recognition as easy as reading two bytes.   # Clients: * [JavaScript](https://github.com/regulaforensics/DocumentReader-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/DocumentReader-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/DocumentReader-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/DocumentReader-web-csharp-client) client for .NET & .NET Core 
 *
 * The version of the OpenAPI document: 7.6.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Regula.DocumentReader.WebClient.Client;

namespace Regula.DocumentReader.WebClient.Model
{
    /// <summary>
    /// SymbolEstimationItem
    /// </summary>
    public partial class SymbolEstimationItem : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SymbolEstimationItem" /> class.
        /// </summary>
        /// <param name="aLIGNMENTNEARESTSYMBOLS">aLIGNMENTNEARESTSYMBOLS</param>
        /// <param name="cONTRASTPRINT">cONTRASTPRINT</param>
        /// <param name="cONTRASTSYMBOL">cONTRASTSYMBOL</param>
        /// <param name="charSymbol">charSymbol</param>
        /// <param name="eDGE">eDGE</param>
        /// <param name="eMPTINESS">eMPTINESS</param>
        /// <param name="sTAIN">sTAIN</param>
        /// <param name="sYMBOLSINTERVAL">sYMBOLSINTERVAL</param>
        /// <param name="sYMBOLPARAM">sYMBOLPARAM</param>
        /// <param name="sYMBOLSIZE">sYMBOLSIZE</param>
        /// <param name="sizeErrorAlignWithNext">sizeErrorAlignWithNext</param>
        /// <param name="sizeErrorAlignWithPrev">sizeErrorAlignWithPrev</param>
        /// <param name="sizeErrorIntervWithNext">sizeErrorIntervWithNext</param>
        /// <param name="sizeErrorIntervWithPrev">sizeErrorIntervWithPrev</param>
        /// <param name="sizeErrorSymbolHeight">sizeErrorSymbolHeight</param>
        /// <param name="sizeErrorSymbolWidth">sizeErrorSymbolWidth</param>
        /// <param name="symbolBounds">symbolBounds</param>
        [JsonConstructor]
        public SymbolEstimationItem(int aLIGNMENTNEARESTSYMBOLS, int cONTRASTPRINT, int cONTRASTSYMBOL, int charSymbol, int eDGE, int eMPTINESS, int sTAIN, int sYMBOLSINTERVAL, int sYMBOLPARAM, int sYMBOLSIZE, decimal sizeErrorAlignWithNext, decimal sizeErrorAlignWithPrev, decimal sizeErrorIntervWithNext, decimal sizeErrorIntervWithPrev, decimal sizeErrorSymbolHeight, decimal sizeErrorSymbolWidth, RectangleCoordinates symbolBounds)
        {
            ALIGNMENT_NEAREST_SYMBOLS = aLIGNMENTNEARESTSYMBOLS;
            CONTRAST_PRINT = cONTRASTPRINT;
            CONTRAST_SYMBOL = cONTRASTSYMBOL;
            CharSymbol = charSymbol;
            EDGE = eDGE;
            EMPTINESS = eMPTINESS;
            STAIN = sTAIN;
            SYMBOLS_INTERVAL = sYMBOLSINTERVAL;
            SYMBOL_PARAM = sYMBOLPARAM;
            SYMBOL_SIZE = sYMBOLSIZE;
            SizeErrorAlignWithNext = sizeErrorAlignWithNext;
            SizeErrorAlignWithPrev = sizeErrorAlignWithPrev;
            SizeErrorIntervWithNext = sizeErrorIntervWithNext;
            SizeErrorIntervWithPrev = sizeErrorIntervWithPrev;
            SizeErrorSymbolHeight = sizeErrorSymbolHeight;
            SizeErrorSymbolWidth = sizeErrorSymbolWidth;
            SymbolBounds = symbolBounds;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets ALIGNMENT_NEAREST_SYMBOLS
        /// </summary>
        [JsonPropertyName("ALIGNMENT_NEAREST_SYMBOLS")]
        public int ALIGNMENT_NEAREST_SYMBOLS { get; set; }

        /// <summary>
        /// Gets or Sets CONTRAST_PRINT
        /// </summary>
        [JsonPropertyName("CONTRAST_PRINT")]
        public int CONTRAST_PRINT { get; set; }

        /// <summary>
        /// Gets or Sets CONTRAST_SYMBOL
        /// </summary>
        [JsonPropertyName("CONTRAST_SYMBOL")]
        public int CONTRAST_SYMBOL { get; set; }

        /// <summary>
        /// Gets or Sets CharSymbol
        /// </summary>
        [JsonPropertyName("CharSymbol")]
        public int CharSymbol { get; set; }

        /// <summary>
        /// Gets or Sets EDGE
        /// </summary>
        [JsonPropertyName("EDGE")]
        public int EDGE { get; set; }

        /// <summary>
        /// Gets or Sets EMPTINESS
        /// </summary>
        [JsonPropertyName("EMPTINESS")]
        public int EMPTINESS { get; set; }

        /// <summary>
        /// Gets or Sets STAIN
        /// </summary>
        [JsonPropertyName("STAIN")]
        public int STAIN { get; set; }

        /// <summary>
        /// Gets or Sets SYMBOLS_INTERVAL
        /// </summary>
        [JsonPropertyName("SYMBOLS_INTERVAL")]
        public int SYMBOLS_INTERVAL { get; set; }

        /// <summary>
        /// Gets or Sets SYMBOL_PARAM
        /// </summary>
        [JsonPropertyName("SYMBOL_PARAM")]
        public int SYMBOL_PARAM { get; set; }

        /// <summary>
        /// Gets or Sets SYMBOL_SIZE
        /// </summary>
        [JsonPropertyName("SYMBOL_SIZE")]
        public int SYMBOL_SIZE { get; set; }

        /// <summary>
        /// Gets or Sets SizeErrorAlignWithNext
        /// </summary>
        [JsonPropertyName("SizeErrorAlignWithNext")]
        public decimal SizeErrorAlignWithNext { get; set; }

        /// <summary>
        /// Gets or Sets SizeErrorAlignWithPrev
        /// </summary>
        [JsonPropertyName("SizeErrorAlignWithPrev")]
        public decimal SizeErrorAlignWithPrev { get; set; }

        /// <summary>
        /// Gets or Sets SizeErrorIntervWithNext
        /// </summary>
        [JsonPropertyName("SizeErrorIntervWithNext")]
        public decimal SizeErrorIntervWithNext { get; set; }

        /// <summary>
        /// Gets or Sets SizeErrorIntervWithPrev
        /// </summary>
        [JsonPropertyName("SizeErrorIntervWithPrev")]
        public decimal SizeErrorIntervWithPrev { get; set; }

        /// <summary>
        /// Gets or Sets SizeErrorSymbolHeight
        /// </summary>
        [JsonPropertyName("SizeErrorSymbolHeight")]
        public decimal SizeErrorSymbolHeight { get; set; }

        /// <summary>
        /// Gets or Sets SizeErrorSymbolWidth
        /// </summary>
        [JsonPropertyName("SizeErrorSymbolWidth")]
        public decimal SizeErrorSymbolWidth { get; set; }

        /// <summary>
        /// Gets or Sets SymbolBounds
        /// </summary>
        [JsonPropertyName("SymbolBounds")]
        public RectangleCoordinates SymbolBounds { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class SymbolEstimationItem {\n");
            sb.Append("  ALIGNMENT_NEAREST_SYMBOLS: ").Append(ALIGNMENT_NEAREST_SYMBOLS).Append("\n");
            sb.Append("  CONTRAST_PRINT: ").Append(CONTRAST_PRINT).Append("\n");
            sb.Append("  CONTRAST_SYMBOL: ").Append(CONTRAST_SYMBOL).Append("\n");
            sb.Append("  CharSymbol: ").Append(CharSymbol).Append("\n");
            sb.Append("  EDGE: ").Append(EDGE).Append("\n");
            sb.Append("  EMPTINESS: ").Append(EMPTINESS).Append("\n");
            sb.Append("  STAIN: ").Append(STAIN).Append("\n");
            sb.Append("  SYMBOLS_INTERVAL: ").Append(SYMBOLS_INTERVAL).Append("\n");
            sb.Append("  SYMBOL_PARAM: ").Append(SYMBOL_PARAM).Append("\n");
            sb.Append("  SYMBOL_SIZE: ").Append(SYMBOL_SIZE).Append("\n");
            sb.Append("  SizeErrorAlignWithNext: ").Append(SizeErrorAlignWithNext).Append("\n");
            sb.Append("  SizeErrorAlignWithPrev: ").Append(SizeErrorAlignWithPrev).Append("\n");
            sb.Append("  SizeErrorIntervWithNext: ").Append(SizeErrorIntervWithNext).Append("\n");
            sb.Append("  SizeErrorIntervWithPrev: ").Append(SizeErrorIntervWithPrev).Append("\n");
            sb.Append("  SizeErrorSymbolHeight: ").Append(SizeErrorSymbolHeight).Append("\n");
            sb.Append("  SizeErrorSymbolWidth: ").Append(SizeErrorSymbolWidth).Append("\n");
            sb.Append("  SymbolBounds: ").Append(SymbolBounds).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="SymbolEstimationItem" />
    /// </summary>
    public class SymbolEstimationItemJsonConverter : JsonConverter<SymbolEstimationItem>
    {
        /// <summary>
        /// Deserializes json to <see cref="SymbolEstimationItem" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override SymbolEstimationItem Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<int?> aLIGNMENTNEARESTSYMBOLS = default;
            Option<int?> cONTRASTPRINT = default;
            Option<int?> cONTRASTSYMBOL = default;
            Option<int?> charSymbol = default;
            Option<int?> eDGE = default;
            Option<int?> eMPTINESS = default;
            Option<int?> sTAIN = default;
            Option<int?> sYMBOLSINTERVAL = default;
            Option<int?> sYMBOLPARAM = default;
            Option<int?> sYMBOLSIZE = default;
            Option<decimal?> sizeErrorAlignWithNext = default;
            Option<decimal?> sizeErrorAlignWithPrev = default;
            Option<decimal?> sizeErrorIntervWithNext = default;
            Option<decimal?> sizeErrorIntervWithPrev = default;
            Option<decimal?> sizeErrorSymbolHeight = default;
            Option<decimal?> sizeErrorSymbolWidth = default;
            Option<RectangleCoordinates?> symbolBounds = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "ALIGNMENT_NEAREST_SYMBOLS":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                aLIGNMENTNEARESTSYMBOLS = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "CONTRAST_PRINT":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                cONTRASTPRINT = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "CONTRAST_SYMBOL":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                cONTRASTSYMBOL = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "CharSymbol":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                charSymbol = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "EDGE":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                eDGE = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "EMPTINESS":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                eMPTINESS = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "STAIN":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sTAIN = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "SYMBOLS_INTERVAL":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sYMBOLSINTERVAL = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "SYMBOL_PARAM":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sYMBOLPARAM = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "SYMBOL_SIZE":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sYMBOLSIZE = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "SizeErrorAlignWithNext":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sizeErrorAlignWithNext = new Option<decimal?>(utf8JsonReader.GetDecimal());
                            break;
                        case "SizeErrorAlignWithPrev":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sizeErrorAlignWithPrev = new Option<decimal?>(utf8JsonReader.GetDecimal());
                            break;
                        case "SizeErrorIntervWithNext":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sizeErrorIntervWithNext = new Option<decimal?>(utf8JsonReader.GetDecimal());
                            break;
                        case "SizeErrorIntervWithPrev":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sizeErrorIntervWithPrev = new Option<decimal?>(utf8JsonReader.GetDecimal());
                            break;
                        case "SizeErrorSymbolHeight":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sizeErrorSymbolHeight = new Option<decimal?>(utf8JsonReader.GetDecimal());
                            break;
                        case "SizeErrorSymbolWidth":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                sizeErrorSymbolWidth = new Option<decimal?>(utf8JsonReader.GetDecimal());
                            break;
                        case "SymbolBounds":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                symbolBounds = new Option<RectangleCoordinates?>(JsonSerializer.Deserialize<RectangleCoordinates>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!aLIGNMENTNEARESTSYMBOLS.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(aLIGNMENTNEARESTSYMBOLS));

            if (!cONTRASTPRINT.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(cONTRASTPRINT));

            if (!cONTRASTSYMBOL.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(cONTRASTSYMBOL));

            if (!charSymbol.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(charSymbol));

            if (!eDGE.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(eDGE));

            if (!eMPTINESS.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(eMPTINESS));

            if (!sTAIN.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sTAIN));

            if (!sYMBOLSINTERVAL.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sYMBOLSINTERVAL));

            if (!sYMBOLPARAM.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sYMBOLPARAM));

            if (!sYMBOLSIZE.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sYMBOLSIZE));

            if (!sizeErrorAlignWithNext.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sizeErrorAlignWithNext));

            if (!sizeErrorAlignWithPrev.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sizeErrorAlignWithPrev));

            if (!sizeErrorIntervWithNext.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sizeErrorIntervWithNext));

            if (!sizeErrorIntervWithPrev.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sizeErrorIntervWithPrev));

            if (!sizeErrorSymbolHeight.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sizeErrorSymbolHeight));

            if (!sizeErrorSymbolWidth.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(sizeErrorSymbolWidth));

            if (!symbolBounds.IsSet)
                throw new ArgumentException("Property is required for class SymbolEstimationItem.", nameof(symbolBounds));

            if (aLIGNMENTNEARESTSYMBOLS.IsSet && aLIGNMENTNEARESTSYMBOLS.Value == null)
                throw new ArgumentNullException(nameof(aLIGNMENTNEARESTSYMBOLS), "Property is not nullable for class SymbolEstimationItem.");

            if (cONTRASTPRINT.IsSet && cONTRASTPRINT.Value == null)
                throw new ArgumentNullException(nameof(cONTRASTPRINT), "Property is not nullable for class SymbolEstimationItem.");

            if (cONTRASTSYMBOL.IsSet && cONTRASTSYMBOL.Value == null)
                throw new ArgumentNullException(nameof(cONTRASTSYMBOL), "Property is not nullable for class SymbolEstimationItem.");

            if (charSymbol.IsSet && charSymbol.Value == null)
                throw new ArgumentNullException(nameof(charSymbol), "Property is not nullable for class SymbolEstimationItem.");

            if (eDGE.IsSet && eDGE.Value == null)
                throw new ArgumentNullException(nameof(eDGE), "Property is not nullable for class SymbolEstimationItem.");

            if (eMPTINESS.IsSet && eMPTINESS.Value == null)
                throw new ArgumentNullException(nameof(eMPTINESS), "Property is not nullable for class SymbolEstimationItem.");

            if (sTAIN.IsSet && sTAIN.Value == null)
                throw new ArgumentNullException(nameof(sTAIN), "Property is not nullable for class SymbolEstimationItem.");

            if (sYMBOLSINTERVAL.IsSet && sYMBOLSINTERVAL.Value == null)
                throw new ArgumentNullException(nameof(sYMBOLSINTERVAL), "Property is not nullable for class SymbolEstimationItem.");

            if (sYMBOLPARAM.IsSet && sYMBOLPARAM.Value == null)
                throw new ArgumentNullException(nameof(sYMBOLPARAM), "Property is not nullable for class SymbolEstimationItem.");

            if (sYMBOLSIZE.IsSet && sYMBOLSIZE.Value == null)
                throw new ArgumentNullException(nameof(sYMBOLSIZE), "Property is not nullable for class SymbolEstimationItem.");

            if (sizeErrorAlignWithNext.IsSet && sizeErrorAlignWithNext.Value == null)
                throw new ArgumentNullException(nameof(sizeErrorAlignWithNext), "Property is not nullable for class SymbolEstimationItem.");

            if (sizeErrorAlignWithPrev.IsSet && sizeErrorAlignWithPrev.Value == null)
                throw new ArgumentNullException(nameof(sizeErrorAlignWithPrev), "Property is not nullable for class SymbolEstimationItem.");

            if (sizeErrorIntervWithNext.IsSet && sizeErrorIntervWithNext.Value == null)
                throw new ArgumentNullException(nameof(sizeErrorIntervWithNext), "Property is not nullable for class SymbolEstimationItem.");

            if (sizeErrorIntervWithPrev.IsSet && sizeErrorIntervWithPrev.Value == null)
                throw new ArgumentNullException(nameof(sizeErrorIntervWithPrev), "Property is not nullable for class SymbolEstimationItem.");

            if (sizeErrorSymbolHeight.IsSet && sizeErrorSymbolHeight.Value == null)
                throw new ArgumentNullException(nameof(sizeErrorSymbolHeight), "Property is not nullable for class SymbolEstimationItem.");

            if (sizeErrorSymbolWidth.IsSet && sizeErrorSymbolWidth.Value == null)
                throw new ArgumentNullException(nameof(sizeErrorSymbolWidth), "Property is not nullable for class SymbolEstimationItem.");

            if (symbolBounds.IsSet && symbolBounds.Value == null)
                throw new ArgumentNullException(nameof(symbolBounds), "Property is not nullable for class SymbolEstimationItem.");

            return new SymbolEstimationItem(aLIGNMENTNEARESTSYMBOLS.Value!.Value!, cONTRASTPRINT.Value!.Value!, cONTRASTSYMBOL.Value!.Value!, charSymbol.Value!.Value!, eDGE.Value!.Value!, eMPTINESS.Value!.Value!, sTAIN.Value!.Value!, sYMBOLSINTERVAL.Value!.Value!, sYMBOLPARAM.Value!.Value!, sYMBOLSIZE.Value!.Value!, sizeErrorAlignWithNext.Value!.Value!, sizeErrorAlignWithPrev.Value!.Value!, sizeErrorIntervWithNext.Value!.Value!, sizeErrorIntervWithPrev.Value!.Value!, sizeErrorSymbolHeight.Value!.Value!, sizeErrorSymbolWidth.Value!.Value!, symbolBounds.Value!);
        }

        /// <summary>
        /// Serializes a <see cref="SymbolEstimationItem" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="symbolEstimationItem"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, SymbolEstimationItem symbolEstimationItem, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, symbolEstimationItem, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="SymbolEstimationItem" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="symbolEstimationItem"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, SymbolEstimationItem symbolEstimationItem, JsonSerializerOptions jsonSerializerOptions)
        {
            if (symbolEstimationItem.SymbolBounds == null)
                throw new ArgumentNullException(nameof(symbolEstimationItem.SymbolBounds), "Property is required for class SymbolEstimationItem.");

            writer.WriteNumber("ALIGNMENT_NEAREST_SYMBOLS", symbolEstimationItem.ALIGNMENT_NEAREST_SYMBOLS);

            writer.WriteNumber("CONTRAST_PRINT", symbolEstimationItem.CONTRAST_PRINT);

            writer.WriteNumber("CONTRAST_SYMBOL", symbolEstimationItem.CONTRAST_SYMBOL);

            writer.WriteNumber("CharSymbol", symbolEstimationItem.CharSymbol);

            writer.WriteNumber("EDGE", symbolEstimationItem.EDGE);

            writer.WriteNumber("EMPTINESS", symbolEstimationItem.EMPTINESS);

            writer.WriteNumber("STAIN", symbolEstimationItem.STAIN);

            writer.WriteNumber("SYMBOLS_INTERVAL", symbolEstimationItem.SYMBOLS_INTERVAL);

            writer.WriteNumber("SYMBOL_PARAM", symbolEstimationItem.SYMBOL_PARAM);

            writer.WriteNumber("SYMBOL_SIZE", symbolEstimationItem.SYMBOL_SIZE);

            writer.WriteNumber("SizeErrorAlignWithNext", symbolEstimationItem.SizeErrorAlignWithNext);

            writer.WriteNumber("SizeErrorAlignWithPrev", symbolEstimationItem.SizeErrorAlignWithPrev);

            writer.WriteNumber("SizeErrorIntervWithNext", symbolEstimationItem.SizeErrorIntervWithNext);

            writer.WriteNumber("SizeErrorIntervWithPrev", symbolEstimationItem.SizeErrorIntervWithPrev);

            writer.WriteNumber("SizeErrorSymbolHeight", symbolEstimationItem.SizeErrorSymbolHeight);

            writer.WriteNumber("SizeErrorSymbolWidth", symbolEstimationItem.SizeErrorSymbolWidth);

            writer.WritePropertyName("SymbolBounds");
            JsonSerializer.Serialize(writer, symbolEstimationItem.SymbolBounds, jsonSerializerOptions);
        }
    }
}
