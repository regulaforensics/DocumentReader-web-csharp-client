// <auto-generated>
/*
 * Regula Document Reader Web API
 *
 * Documents recognition as easy as reading two bytes.   # Clients: * [JavaScript](https://github.com/regulaforensics/DocumentReader-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/DocumentReader-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/DocumentReader-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/DocumentReader-web-csharp-client) client for .NET & .NET Core 
 *
 * The version of the OpenAPI document: 7.6.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Regula.DocumentReader.WebClient.Client;

namespace Regula.DocumentReader.WebClient.Model
{
    /// <summary>
    /// Contains information about one document type candidate
    /// </summary>
    public partial class ChosenDocumentType : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChosenDocumentType" /> class.
        /// </summary>
        /// <param name="documentName">Document name</param>
        /// <param name="iD">Unique document type template identifier (Regula&#39;s internal numeric code)</param>
        /// <param name="p">A measure of the likelihood of correct recognition in the analysis of this type of document</param>
        /// <param name="rotated180">true if the document of the given type is rotated by 180 degrees</param>
        /// <param name="rFIDPresence">rFIDPresence</param>
        /// <param name="fDSIDList">fDSIDList</param>
        /// <param name="necessaryLights">Combination of lighting scheme identifiers (Light enum) required to conduct OCR for this type of document</param>
        /// <param name="checkAuthenticity">Set of authentication options provided for this type of document (combination of Authenticity enum)</param>
        /// <param name="uVExp">The required exposure value of the camera when receiving images of a document of this type for a UV lighting scheme</param>
        /// <param name="authenticityNecessaryLights">Combination of lighting scheme identifiers (combination of Light enum) needed to perform all authenticity checks specified in CheckAuthenticity</param>
        /// <param name="oVIExp">Camera exposure value necessary when obtaining document images of the given type for AXIAL lighting scheme</param>
        /// <param name="rotationAngle">rotationAngle</param>
        [JsonConstructor]
        public ChosenDocumentType(string documentName, int iD, decimal p, int rotated180, RfidLocation rFIDPresence, FDSIDList fDSIDList, int necessaryLights, int checkAuthenticity, int uVExp, int authenticityNecessaryLights, decimal oVIExp, Option<int?> rotationAngle = default)
        {
            DocumentName = documentName;
            ID = iD;
            P = p;
            Rotated180 = rotated180;
            RFIDPresence = rFIDPresence;
            FDSIDList = fDSIDList;
            NecessaryLights = necessaryLights;
            CheckAuthenticity = checkAuthenticity;
            UVExp = uVExp;
            AuthenticityNecessaryLights = authenticityNecessaryLights;
            OVIExp = oVIExp;
            RotationAngleOption = rotationAngle;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets RFIDPresence
        /// </summary>
        [JsonPropertyName("RFID_Presence")]
        public RfidLocation RFIDPresence { get; set; }

        /// <summary>
        /// Document name
        /// </summary>
        /// <value>Document name</value>
        [JsonPropertyName("DocumentName")]
        public string DocumentName { get; set; }

        /// <summary>
        /// Unique document type template identifier (Regula&#39;s internal numeric code)
        /// </summary>
        /// <value>Unique document type template identifier (Regula&#39;s internal numeric code)</value>
        [JsonPropertyName("ID")]
        public int ID { get; set; }

        /// <summary>
        /// A measure of the likelihood of correct recognition in the analysis of this type of document
        /// </summary>
        /// <value>A measure of the likelihood of correct recognition in the analysis of this type of document</value>
        /* <example>0.9913095831871032</example> */
        [JsonPropertyName("P")]
        public decimal P { get; set; }

        /// <summary>
        /// true if the document of the given type is rotated by 180 degrees
        /// </summary>
        /// <value>true if the document of the given type is rotated by 180 degrees</value>
        [JsonPropertyName("Rotated180")]
        public int Rotated180 { get; set; }

        /// <summary>
        /// Gets or Sets FDSIDList
        /// </summary>
        [JsonPropertyName("FDSIDList")]
        public FDSIDList FDSIDList { get; set; }

        /// <summary>
        /// Combination of lighting scheme identifiers (Light enum) required to conduct OCR for this type of document
        /// </summary>
        /// <value>Combination of lighting scheme identifiers (Light enum) required to conduct OCR for this type of document</value>
        [JsonPropertyName("NecessaryLights")]
        public int NecessaryLights { get; set; }

        /// <summary>
        /// Set of authentication options provided for this type of document (combination of Authenticity enum)
        /// </summary>
        /// <value>Set of authentication options provided for this type of document (combination of Authenticity enum)</value>
        [JsonPropertyName("CheckAuthenticity")]
        public int CheckAuthenticity { get; set; }

        /// <summary>
        /// The required exposure value of the camera when receiving images of a document of this type for a UV lighting scheme
        /// </summary>
        /// <value>The required exposure value of the camera when receiving images of a document of this type for a UV lighting scheme</value>
        [JsonPropertyName("UVExp")]
        public int UVExp { get; set; }

        /// <summary>
        /// Combination of lighting scheme identifiers (combination of Light enum) needed to perform all authenticity checks specified in CheckAuthenticity
        /// </summary>
        /// <value>Combination of lighting scheme identifiers (combination of Light enum) needed to perform all authenticity checks specified in CheckAuthenticity</value>
        [JsonPropertyName("AuthenticityNecessaryLights")]
        public int AuthenticityNecessaryLights { get; set; }

        /// <summary>
        /// Camera exposure value necessary when obtaining document images of the given type for AXIAL lighting scheme
        /// </summary>
        /// <value>Camera exposure value necessary when obtaining document images of the given type for AXIAL lighting scheme</value>
        [JsonPropertyName("OVIExp")]
        public decimal OVIExp { get; set; }

        /// <summary>
        /// Used to track the state of RotationAngle
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> RotationAngleOption { get; private set; }

        /// <summary>
        /// Gets or Sets RotationAngle
        /// </summary>
        [JsonPropertyName("RotationAngle")]
        public int? RotationAngle { get { return this.RotationAngleOption; } set { this.RotationAngleOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ChosenDocumentType {\n");
            sb.Append("  DocumentName: ").Append(DocumentName).Append("\n");
            sb.Append("  ID: ").Append(ID).Append("\n");
            sb.Append("  P: ").Append(P).Append("\n");
            sb.Append("  Rotated180: ").Append(Rotated180).Append("\n");
            sb.Append("  RFIDPresence: ").Append(RFIDPresence).Append("\n");
            sb.Append("  FDSIDList: ").Append(FDSIDList).Append("\n");
            sb.Append("  NecessaryLights: ").Append(NecessaryLights).Append("\n");
            sb.Append("  CheckAuthenticity: ").Append(CheckAuthenticity).Append("\n");
            sb.Append("  UVExp: ").Append(UVExp).Append("\n");
            sb.Append("  AuthenticityNecessaryLights: ").Append(AuthenticityNecessaryLights).Append("\n");
            sb.Append("  OVIExp: ").Append(OVIExp).Append("\n");
            sb.Append("  RotationAngle: ").Append(RotationAngle).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // P (decimal) maximum
            if (this.P > (decimal)1)
            {
                yield return new ValidationResult("Invalid value for P, must be a value less than or equal to 1.", new [] { "P" });
            }

            // P (decimal) minimum
            if (this.P < (decimal)0)
            {
                yield return new ValidationResult("Invalid value for P, must be a value greater than or equal to 0.", new [] { "P" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="ChosenDocumentType" />
    /// </summary>
    public class ChosenDocumentTypeJsonConverter : JsonConverter<ChosenDocumentType>
    {
        /// <summary>
        /// Deserializes json to <see cref="ChosenDocumentType" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override ChosenDocumentType Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> documentName = default;
            Option<int?> iD = default;
            Option<decimal?> p = default;
            Option<int?> rotated180 = default;
            Option<RfidLocation?> rFIDPresence = default;
            Option<FDSIDList?> fDSIDList = default;
            Option<int?> necessaryLights = default;
            Option<int?> checkAuthenticity = default;
            Option<int?> uVExp = default;
            Option<int?> authenticityNecessaryLights = default;
            Option<decimal?> oVIExp = default;
            Option<int?> rotationAngle = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "DocumentName":
                            documentName = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "ID":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                iD = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "P":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                p = new Option<decimal?>(utf8JsonReader.GetDecimal());
                            break;
                        case "Rotated180":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                rotated180 = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "RFID_Presence":
                            string? rFIDPresenceRawValue = utf8JsonReader.GetString();
                            if (rFIDPresenceRawValue != null)
                                rFIDPresence = new Option<RfidLocation?>(RfidLocationValueConverter.FromStringOrDefault(rFIDPresenceRawValue));
                            break;
                        case "FDSIDList":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                fDSIDList = new Option<FDSIDList?>(JsonSerializer.Deserialize<FDSIDList>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "NecessaryLights":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                necessaryLights = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "CheckAuthenticity":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                checkAuthenticity = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "UVExp":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                uVExp = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "AuthenticityNecessaryLights":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                authenticityNecessaryLights = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        case "OVIExp":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                oVIExp = new Option<decimal?>(utf8JsonReader.GetDecimal());
                            break;
                        case "RotationAngle":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                rotationAngle = new Option<int?>(utf8JsonReader.GetInt32());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!documentName.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(documentName));

            if (!iD.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(iD));

            if (!p.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(p));

            if (!rotated180.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(rotated180));

            if (!rFIDPresence.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(rFIDPresence));

            if (!fDSIDList.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(fDSIDList));

            if (!necessaryLights.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(necessaryLights));

            if (!checkAuthenticity.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(checkAuthenticity));

            if (!uVExp.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(uVExp));

            if (!authenticityNecessaryLights.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(authenticityNecessaryLights));

            if (!oVIExp.IsSet)
                throw new ArgumentException("Property is required for class ChosenDocumentType.", nameof(oVIExp));

            if (documentName.IsSet && documentName.Value == null)
                throw new ArgumentNullException(nameof(documentName), "Property is not nullable for class ChosenDocumentType.");

            if (iD.IsSet && iD.Value == null)
                throw new ArgumentNullException(nameof(iD), "Property is not nullable for class ChosenDocumentType.");

            if (p.IsSet && p.Value == null)
                throw new ArgumentNullException(nameof(p), "Property is not nullable for class ChosenDocumentType.");

            if (rotated180.IsSet && rotated180.Value == null)
                throw new ArgumentNullException(nameof(rotated180), "Property is not nullable for class ChosenDocumentType.");

            if (rFIDPresence.IsSet && rFIDPresence.Value == null)
                throw new ArgumentNullException(nameof(rFIDPresence), "Property is not nullable for class ChosenDocumentType.");

            if (fDSIDList.IsSet && fDSIDList.Value == null)
                throw new ArgumentNullException(nameof(fDSIDList), "Property is not nullable for class ChosenDocumentType.");

            if (necessaryLights.IsSet && necessaryLights.Value == null)
                throw new ArgumentNullException(nameof(necessaryLights), "Property is not nullable for class ChosenDocumentType.");

            if (checkAuthenticity.IsSet && checkAuthenticity.Value == null)
                throw new ArgumentNullException(nameof(checkAuthenticity), "Property is not nullable for class ChosenDocumentType.");

            if (uVExp.IsSet && uVExp.Value == null)
                throw new ArgumentNullException(nameof(uVExp), "Property is not nullable for class ChosenDocumentType.");

            if (authenticityNecessaryLights.IsSet && authenticityNecessaryLights.Value == null)
                throw new ArgumentNullException(nameof(authenticityNecessaryLights), "Property is not nullable for class ChosenDocumentType.");

            if (oVIExp.IsSet && oVIExp.Value == null)
                throw new ArgumentNullException(nameof(oVIExp), "Property is not nullable for class ChosenDocumentType.");

            if (rotationAngle.IsSet && rotationAngle.Value == null)
                throw new ArgumentNullException(nameof(rotationAngle), "Property is not nullable for class ChosenDocumentType.");

            return new ChosenDocumentType(documentName.Value!, iD.Value!.Value!, p.Value!.Value!, rotated180.Value!.Value!, rFIDPresence.Value!.Value!, fDSIDList.Value!, necessaryLights.Value!.Value!, checkAuthenticity.Value!.Value!, uVExp.Value!.Value!, authenticityNecessaryLights.Value!.Value!, oVIExp.Value!.Value!, rotationAngle);
        }

        /// <summary>
        /// Serializes a <see cref="ChosenDocumentType" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="chosenDocumentType"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, ChosenDocumentType chosenDocumentType, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, chosenDocumentType, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="ChosenDocumentType" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="chosenDocumentType"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, ChosenDocumentType chosenDocumentType, JsonSerializerOptions jsonSerializerOptions)
        {
            if (chosenDocumentType.DocumentName == null)
                throw new ArgumentNullException(nameof(chosenDocumentType.DocumentName), "Property is required for class ChosenDocumentType.");

            if (chosenDocumentType.FDSIDList == null)
                throw new ArgumentNullException(nameof(chosenDocumentType.FDSIDList), "Property is required for class ChosenDocumentType.");

            writer.WriteString("DocumentName", chosenDocumentType.DocumentName);

            writer.WriteNumber("ID", chosenDocumentType.ID);

            writer.WriteNumber("P", chosenDocumentType.P);

            writer.WriteNumber("Rotated180", chosenDocumentType.Rotated180);

            var rFIDPresenceRawValue = RfidLocationValueConverter.ToJsonValue(chosenDocumentType.RFIDPresence);
            writer.WriteNumber("RFID_Presence", rFIDPresenceRawValue);

            writer.WritePropertyName("FDSIDList");
            JsonSerializer.Serialize(writer, chosenDocumentType.FDSIDList, jsonSerializerOptions);
            writer.WriteNumber("NecessaryLights", chosenDocumentType.NecessaryLights);

            writer.WriteNumber("CheckAuthenticity", chosenDocumentType.CheckAuthenticity);

            writer.WriteNumber("UVExp", chosenDocumentType.UVExp);

            writer.WriteNumber("AuthenticityNecessaryLights", chosenDocumentType.AuthenticityNecessaryLights);

            writer.WriteNumber("OVIExp", chosenDocumentType.OVIExp);

            if (chosenDocumentType.RotationAngleOption.IsSet)
                writer.WriteNumber("RotationAngle", chosenDocumentType.RotationAngleOption.Value!.Value);
        }
    }
}
